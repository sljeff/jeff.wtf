{"meta":{"title":"善良的杰夫","subtitle":null,"description":null,"author":"Jeff","url":"https://jeff.wtf"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-01-28T07:31:30.733Z","updated":"2019-01-28T07:31:30.733Z","comments":false,"path":"/404.html","permalink":"https://jeff.wtf//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-01-28T07:31:30.744Z","updated":"2019-01-28T07:31:30.744Z","comments":false,"path":"about/index.html","permalink":"https://jeff.wtf/about/index.html","excerpt":"","text":"善良的杰夫扇贝网 Python 工程师"},{"title":"分类","date":"2019-01-28T07:31:30.745Z","updated":"2019-01-28T07:31:30.745Z","comments":false,"path":"categories/index.html","permalink":"https://jeff.wtf/categories/index.html","excerpt":"","text":""},{"title":"Github","date":"2019-01-28T07:31:30.745Z","updated":"2019-01-28T07:31:30.745Z","comments":false,"path":"repository/index.html","permalink":"https://jeff.wtf/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"批评者和被批评者的消亡","slug":"the-critics","date":"2018-08-04T16:03:26.000Z","updated":"2019-01-28T07:31:30.742Z","comments":true,"path":"2018/08/the-critics/","link":"","permalink":"https://jeff.wtf/2018/08/the-critics/","excerpt":"","text":"网易云音乐给我随机播放到一首日本偶像团体的歌。翻一翻评论，看到粉丝在下面吵架。本来偶像团体的粉丝吵架是再正常不过（误），但是在我不熟悉这个团体的人看来，下面两边应该是同一批粉丝才对。 于是去问了一个是粉丝的朋友。他告诉我这个团体名字有汉字写法，又有假名写法，这两个名字可以把她们当成两个团来看。 在日本偶像行业这样经过充分竞争的市场，这样的事情好像很常见：杰尼斯的艺人之间，既要像是「一家人」的关系，亲密互动，又要是竞争对手，来制造话题和新闻；48系既要是一整个团体紧紧联系在一起，又要分地域、地域下分队伍、队伍间有小团体；46系外部要把48系当作官方对手，内部又要分团体、团体下居然还要分汉字写法还是假名写法。 这种做法几乎是偶像团体受欢迎的公式之一。这样做的目的一方面是为了话题性，所谓流量；另一方面还是为了保持竞争。竞争带来了批评，批评带来活力。 之前看到游研社一篇文章写，腾讯游戏进入了天美和光子的双雄时代。 最近腾讯两款吃鸡手游的比拼看下来，光子的《刺激战场》相比天美的《全军出击》已经明显占据上风；更早的手游时代，光子的《全民超神》则是被天美的《王者荣耀》完败。 腾讯这样体量和实力的公司愿意投入资本，外加「吃鸡」或者「英雄联盟」这种IP，做出来的游戏，想不火应该都是很困难的。但腾讯还是要投入双倍的资源，让两个内部的工作室做一样题材的游戏出来。 正是因为「形势一片大好」，又缺乏外部竞争，不让两个内部工作室同时研发的后果就是没有办法知道游戏是不是做的足够好。引用游研社的一句话： 相比市场外部，腾讯内部的竞争或许更为激烈。 虽然两个工作室都是一家公司的，但出于利益最大化考虑的资本，更想看到两者充分的竞争。 如同开源世界中，Firefox团队会送给Chrome团队蛋糕，但也会批评Chrome的隐私策略；VS code团队和atom团队会借鉴对方的技术，但也会指出对方技术上的缺陷。 前段时间《复仇者联盟3》大火的时候，有一个微博热门，内容是刘慈欣在一个采访里表示「一直不喜欢漫威电影」。 保证有人说「我不喜欢」的权利是很重要的。这是保证文化多样性的重要前提。 美国作家怀特有这么一个说法：当代艺术和文学有一个很大的变化，那就是「批评家的消亡」。 今天，批评者或许还在，但「被批评者」已经不存在了。 面对今天的批评者，今天的「被批评者」和其拥趸可以说你是外行，可以说你是同行来抹黑，可以怀疑你的立场和动机。批评者不再被当作批评者，而是被当作「攻击者」；那批评自然也不是批评，而是「攻击」。 知乎上有个问题问为什么现在辩论赛的观赏性变低了，有人回答说： 辩论圈是这样的，看到有人说我不好，首先看这个人是谁，然后把他归入一个派别、团体，然后找出那个派别和我的利益冲突或者恩怨历史，然后终于得出这个人的动机，然后抛出他的黑点，也就是反击。至于这个人到底说了什么，有没有几分道理，who cares ？ 甚至就有很不错的辩手说，你们网民就是不配评论我们高贵的辩论赛。（类似于，你们知乎这些loser辩手不配……） 一个不接受批评的圈子，走下坡路，是天道。 在文化和艺术领域，资本似乎不需要批评的声音，反而能获取更大的利益。 《西虹市首富》这个电影是最近的热门。大多数人是觉得好看的，但在即刻上刷到两则影评，都很长，觉得这部电影不好看。其中一篇还专门注明了，说知道大家都觉得好看，自己只是站在自己的角度做个影评。 结果还是被骂的体无完肤。评论有两个流派分别是：「你就是为了装X，故意搞特立独行」「就是优越感，好像众人皆醉我独醒」和「大家都觉得好看的不就是好电影了吗，讲这么多内涵干嘛」「电影院的都笑了就已经是好的喜剧电影了吗，我才不管他拍的好不好」。 别人一开口批评，就怀疑别人的动机，而不谈论别人的内容——这不是讨论问题的态度，是时刻准备吵架的态度。 最近被讨论非常多的陈一发事件，争论的点主要是陈一发的视频是不是断章取义、或者陈一发到底有没有调侃和侮辱的意思、以及到底她是自己作死还是被人陷害这些事上。 在我看来，就陈一发这件事本身来说，她是错了；但是除开这个事本身，这个事情外发生的事性质更加恶劣：直接把她封禁，不再给她说话的机会。 可以直接堵住一个人的嘴，这是一件非常恶劣的事。 就像封禁PG One的时候大家纷纷叫好一样，封禁暴走漫画的时候大家骂声一片；封禁内涵段子的时候则是骂声叫好声都有。 不管大家在叫好还是叫骂，都改变不了这些事情性质的恶劣。封禁PG One和封禁暴走漫画、封禁内涵段子、封禁陈一发的性质都一样恶劣。 我想看到的，要么是有完整的法律法规，要么是有合理的执法过程，要么是有法庭上类似先例的判决。而不是悄无声息地抹杀，让人不能说话。 抹杀掉你讨厌的人，你还能跪在地上说「皇恩浩荡」；轮到自己头上时，才知道有多可怕。 前天和扇贝一个同事聊了陈一发事件。 他赞同我的说法，一个人不应该悄无声息地被堵住嘴巴。 他在知乎是个小V。于是他在知乎的相应问题下回答，表达了这个观点。你可以说他是错的，可以批评他，但是不能堵住他的嘴不让他发声。 然后他的答案被知乎删除了。 在被知乎堵上嘴之前，有很多人过来反驳他，基本是说封禁陈一发是斗鱼平台的决定，不是「国家意志」，跟其他封禁事件比起来，这件事是合理的。 然而前提是，摆在斗鱼面前的，是今年以来「暴走漫画」、「内涵段子」、「互联网视频整治」等等的前车之鉴。它不过是出于恐惧，做出了自我阉割。 知乎删掉这个回答，是一样的自我阉割。人不敢言，道路以目。 「政治正确」似乎在席卷整个世界。 有一部分大环境的原因，想要找到优质的、新闻类型的中文内容是非常困难的。但是由于「政治正确」的笼罩，即使想要找到不政治敏感的时事话题的优质内容也是非常困难。 好奇心日报算是一个难得的优秀的媒体网站，有数据、能分析、有深度、还敢批评。 但是： 被批评者不存在了，批评者好像也在慢慢消失。 若批评不自由，则赞美无意义。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]},{"title":"事情的复杂性","slug":"complexity","date":"2018-07-26T16:25:50.000Z","updated":"2019-01-28T07:31:30.734Z","comments":true,"path":"2018/07/complexity/","link":"","permalink":"https://jeff.wtf/2018/07/complexity/","excerpt":"","text":"最近换组频繁，昨天又被换回基础业务组，做扇贝单词相关的东西。 做基础业务，不太需要和「人」打交道，一下子睡眠好了很多，人也精神起来。 虽然前一个多月在阅读组做的也是比较基础的内容，主要和数据打交道，但和用户太相关，免不了数据结构和接口的设计需要和产品妥协。 而且在阅读这种业务场景下，数据最终的设计的合理性很大程度上取决于产品的想法：产品认为是A和B是一对多的结构，即使程序员认为不合理，也必须为它保留这样的结构；产品认为有用的功能，即程序员认为被使用到的次数很少，也需要为开发它付出很多时间。 相比之下，虽然单词这个项目最终设计出来的表结构也会反直觉，但它的合理性建立在一些有迹可循的标准上：问一下公司的英语老师，单词的拼写、发音、词典、释义、例句等等会有怎么样的常见情况和特殊情况，特殊情况的比例大约是多少。这样设计出的数据的结构与复杂多变的用户习惯关联不大，产品和程序员都很难有异议。 在阅读组，我遇到的问题是要处理一堆又一堆繁复的逻辑，一个又一个开不完的会；到单词组，我的问题只有一个：这些每秒数千请求的接口，怎么能让它变得更快更稳定。 世界上有很多种不同的复杂的事情，不同的人会觉得不同的事情是复杂或简单。 经典定义下的理工科学生，会喜欢一类「复杂」问题，如：如何最快地从一亿个数里找出最小的一百万个？ 这类问题的特点是：需要被定义的东西少、问题本身理解起来简单；它的解法却可能很复杂。 一个例子是费马大定理：「一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的」。如此简单的一个问题定义，只要学过初等数学的人都能看懂。但它吸引了数百年无数数学家投入进去，直到1995年才被证明出来，还使用上了费马猜想提出后几百年以来发明出的更多的数学工具。 另一个例子是欧几里得的《几何原本》，仅仅在开头定义五条公理，然后推导出一整本书。所以《几何原本》既被叫做数学巨著，也被称为哲学巨著。 我爱玩的游戏《Portal 2》就契合这类问题的特点：你只有一把能射出蓝光和橙光的枪；你身处一个有限的空间；你身边的道具永远只有那么几种；但在这些道具和空间的组合下，游戏制造出了非常多精妙的关卡。 我另一个喜欢的游戏《The Witness》也是这类游戏的典型：你只需要走路和画线，把线从起点连到终点。它的复杂性蕴藏在谜题的解法里，只有解决它时，玩家才会感受到乐趣。 传统的网络游戏就并非这类「复杂」问题。它们往往把复杂性放在规则上：给玩家很多选择；给玩家很多规则；玩家还可以和变化因素更多的「人」一起进行复杂规则下的游戏。这些网络游戏让你投入大量时间，体验到的是在掌握规则和被不定因素影响之间来回摆动的快感。 把繁复的下层总结出来、屏蔽细节，为上层提供好用的工具/结论/接口，大概是数学、物理、计算机这些学科非常相似的地方。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]},{"title":"个人的奋斗，历史的进程","slug":"person-history","date":"2018-02-11T02:53:04.000Z","updated":"2019-01-28T07:31:30.740Z","comments":true,"path":"2018/02/person-history/","link":"","permalink":"https://jeff.wtf/2018/02/person-history/","excerpt":"","text":"老家（一）从2014年开始，我越来越不愿意回老家。每次回老家，我都会清晰地意识到两件事： 中国仍然是一个第三世界国家，仍然是一个发展中国家 身边最普通的平民们、这些占中国人口一半的农民们，在饭桌上仍然是满嘴谎言的吹嘘者，在生活中仍然是缺乏合作能力、没有能力改变自己生活的第三世界人民 这两个事实让我感到极其痛苦。关于第一个事实，我为这个地方地理位置、历史机遇不够好感到痛苦，为城市化进程还不够快感到痛苦；关于第二个事实，我为贫富差距大感到痛苦，为人性的懒惰和反智感到痛苦，为教育普及程度还不够感到痛苦。 这两个事实，一个是历史的进程，一个是个人的奋斗。历史的进程还没到，个人的奋斗还不够。 南京（一）在南京给合租的室友讲过这个事情，给他描述了我的痛苦。他表示理解。然后讲了一下他的意见。 关于老家城市化看不到希望的问题，他觉得由于历史和地理原因确实短时间看不到希望，但是政府的城市化进度已经很快，我应该期待那一天；关于老家的人反智、固执、难以适应现代商业社会的问题，他觉得这些是由于历史进程导致的在农村年纪稍大的人会有的问题，如果年轻人都是这样，才是一个真正的问题。 我并不觉得他真的能理解我、能理解这种痛苦。他是一个江苏人。我想即使是江苏的农村，也比我的老家生活水平高得多。 老家（二）我能记起来的在老家第一次因为这两个事实感到痛苦，是因为听到这里人放的音乐和谈话，感觉到一些人低俗的品味。当时我觉得他们不思进取、懒惰、文化水平低，品味低俗只是因此展示出的一个现象。 第二次可能是在夏天被脏茅厕的蚊子叮得不厌其烦、在晚上被床上大量的蚂蚁爬得浑身难受的时候。因为他们不作为，不尝试去用杀虫剂、电蚊香或者随便什么手段去提高自己的生活质量。当时我觉得他们总是在『战术上勤奋，战略上懒惰』，直接去解决问题而不去提升自己解决问题的手段或者借用更先进的工具，同时对生活质量也没有追求。 之后可能因为他们在饭桌上反智、反科学，可能因为他们对别人施加恶意、嘲笑别人，可能因为他们开不合时宜的玩笑，可能因为他们随便用自己的标准评价别人，可能因为他们固执好面子而无法合作……等等等等，而感到愤怒和痛苦过。总之，都是个人的行为让我感觉痛苦，但这些个人行为往往也是普遍的现象。 有些人爱说『穷山恶水出刁民』，其实就像我的想法一样，把这种恶归咎于个人，忽略了大的历史背景。用马克思那一套来讲，就是忽略了客观事实，只讲人的主观能动性。但人的主观能动性是有限的，让我感觉痛苦的这些原因，其实都有其历史背景的原因。比如不思进取、文化水平低，是因为几十年前的中国教育普及还不够，人民生活也很穷，支付不起教育的费用；比如不使用更先进的工具、对生活质量没有追求，是因为农民的收入水平还很低，离所谓『小康』还差一大截；比如随意评价别人、对人施加恶意，只是因为农民们自己的生活也还不够幸福罢了，需要这些来调剂生活；比如固执好面子、难以适应现代合作，是以上这些原因的结合，带来的历史惯性。 就群体来看，由个人组成的群体的整体行为当然是因为历史大环境决定的。但就个人来说，一些人可以发挥自己的主观能动性，凭借个人的奋斗逃离这个环境。 仔细想一下，这个地区的历史环境应该并不会让我这样的平民老百姓感到痛苦，真正让我痛苦的事情，其实是自己在老家的亲人都是被大环境决定的群体中的一个。 南京（二）我和这位南京室友聊过很多东西。聊过自己有一些遗憾的东西。 我说，即使像我们两个上过大学受过高等教育，从小生活里各种物质资源也很丰富，尚且会觉得『这个事情没做过，那个东西没试过，挺遗憾的』，那我奶奶这样，八十多了，连自己名字都不会写，连手机都不会玩。她会不会，有的时候觉得非常痛苦？会不会在夜深人静的时候，她也想去试试这些事情？会不会觉得自己这一生实在实在太遗憾？ 他说，应该不会，一是作为这个年纪的老人，他们心态可能已经适应了这些变化，不会为这些做不到的事感到痛苦；二是一个人不会因为自己不知道的事情感觉痛苦，很多东西他们不知道，也不知道自己不知道这件事，因此完全不会为这些事感觉烦恼。有的时候，知道得多反而才是痛苦的。 不知道是不是为了让自己好受一点，我觉得他说的很对。 可能是乔布斯说过，用户们不知道真正自己想要的是什么。很多时候，一个需求出现之后，它才成为了一个需求。 但是在信息已经非常发达的今天，很多第三世界国家的人能看见丰富的物质世界了，他们也感觉羡慕，也想和发达国家的人一样过上那样物质丰富的好生活。但是他们做不到，这时他们感觉痛苦了。 我常常想，中国是一个国家，但内部的差别好像是几个世界：一二线城市像发达国家那样发达，穷乡僻壤的生活条件还非常落后。个人精神上的差异和物质上的差异一样大。 老家（三）我觉得奶奶应该已经感受到这种物质差异带来的痛苦了。 老家已经没什么青壮年常住了，年轻人都会外出打工。每年都会有人赚了足够的钱，开着车回来，给父母建大的楼房。布局要按照城市里的，有干净的卫生间、用燃气的厨房、24小时热水的热水器、大电视、空调、瓷砖地板…… 这些在物质上领先老家农村体系好几代的东西，被一次性打包带了回来。它们剧烈地撞击着每一间用泥巴和红砖搭积木一样搭起来的旧房子。旧房子和里面的旧家具旧格局一起倒塌；隔壁四邻都建了新房，新建的房子一个比一个大，一个比一个高。 等啊等，在今年，奶奶终于还是等到了新房子，不过比别人的矮，比别人的小；家具和装修也很拮据。 奶奶是一个很善良的人。今年回来，她整天都要不停地帮忙，不知道在忙的事情是不是真的有意义；有的时候很她不开心；有的时候会表现出来对别人家的嫉妒，有的时候会愤怒。 实际上，她的儿子们，有的毫无作为，有的大起之后大落，有的负债累累。但在这个时候建这个新房子，是一件不得不完成的事。 南京（三）和他说过，我老家这边建房，就真的和初中语文课本里的《台阶》这篇文章一样。『我们家的台阶低！』，课文里出现的这句话，真的也会从我奶奶嘴里说出来。 他说没有见过这篇课文。因为他是江苏人，用苏教版，我用的是人教版。 老家（四）虽然精神上不见得已经有了变化，但物质上的追求使得这边的『个人』们『奋斗』起来了。精神上还需要等待『历史的进程』。至少随着物质的丰富，精神上的富足也是一件看起来有希望的事。 而让我奶奶痛苦的，不是历史大环境的变迁，而是她的孩子们，是这个进程中掉队的几个人。 南京（四）有的时候我会耍嘴皮子，对于我做到了但是他没做到的事，我会说：『不仅要看历史的进程，也要看个人的奋斗』；对于我做不到的事，我就会说『不仅要看个人的奋斗，也要看历史的进程』。 之前对这种行为自己觉得很可笑，会把自己叫『精致的利己主义者』。现在想想其实是有点道理的：『个人的奋斗』和『历史的进程』虽然像辩证法里的两面，分析一个事情的时候，两者像两个维度一样要去分析；但是它们确实是在相互依赖，互相影响。 五『历史的进程』并没有给出有利的条件，被它影响的『个人的奋斗』又很缺乏。这是奶奶痛苦的根源。她比我更痛苦的原因是，我觉得我还大有前途，但她已经八十多了。 我常常会想象老人面对死亡的感受。我的这个自我意识会消失么？我应该怎么和这个世界告别？能不能让我的意识多活一天？我应该做了什么才会心满意足的完全消失？宗教？信仰？ 我在想，突然离世的人可能最多只是肉体上瞬时的痛苦，而老到身体不能承受而去世的人，是不是每天都会面对这些问题的煎熬？ 生前不管身后事。我这样的想法是对老人家的不尊重，用老家的说法是不吉利。但我阻止不了自己去思考这些事。看到奶奶每天不停地帮忙工作，就会自然想到，她是不是也考虑到了和我一样的问题？是不是在抢自己的时间？ 我告诉奶奶，『公司给我毕业之后开的年薪很高，一年十几万呢！』，我在她面前炫富，希望她能觉得，挣钱已经不是那么困难了，我作为她的孙子，在物质和精神上都很富足，和别人的差距并不大了。能不能让她稍微不那么痛苦一点呢？ 这个年薪在老家建个大房子应该绰绰有余了吧。但是我还有半年才能毕业，毕业后不知道一年还是两年还是三年能攒够这个钱，不知道奶奶还有没有时间等我。个人的奋斗终究是有限的，希望这个部分的历史进程能稍微走慢一点。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]},{"title":"jeff.wtf的第一篇文章","slug":"jeff-wtf-first","date":"2017-11-25T16:19:13.000Z","updated":"2019-01-28T07:31:30.735Z","comments":true,"path":"2017/11/jeff-wtf-first/","link":"","permalink":"https://jeff.wtf/2017/11/jeff-wtf-first/","excerpt":"","text":"为了淘宝送的手机卡买了台手机。 为了外卖送的鸡蛋买了个火锅。 为了一个域名又搭了个博客。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]},{"title":"I/O 多路复用入门——select/poll/epoll","slug":"IO-multiplexing","date":"2017-02-11T12:43:14.000Z","updated":"2019-01-28T07:31:30.734Z","comments":true,"path":"2017/02/IO-multiplexing/","link":"","permalink":"https://jeff.wtf/2017/02/IO-multiplexing/","excerpt":"","text":"为什么要 I/O 多路复用当需要从一个叫 r_fd 的描述符不停地读取数据，并把读到的数据写入一个叫 w_fd 的描述符时，我们可以用循环使用阻塞 I/O ： 123while((n = read(r_fd, buf, BUF_SIZE)) &gt; 0) if(write(w_fd, buf, n) != n) err_sys(\"write error\"); 但是，如果要从两个地方读取数据呢？这时，不能再使用会把程序阻塞住的 read 函数。因为可能在阻塞地等待 r_fd1 的数据时，来不及处理 r_fd2，已经到达的 r_fd2 的数据可能会丢失掉。 这个情况下需要使用非阻塞 I/O。 只要做个标记，把文件描述符标记为非阻塞的，以后再对它使用 read 函数：如果它还没有数据可读，函数会立即返回并把 errorno 这个变量的值设置为 35，于是我们知道它没有数据可读，然后可以立马去对其他描述符使用 read；如果它有数据可读，我们就读取它数据。对所有要读的描述符都调用了一遍 read 之后，我们可以等一个较长的时间（比如几秒），然后再从第一个文件描述符开始调用 read 。这种循环就叫做轮询（polling）。 这样，不会像使用阻塞 I/O 时那样因为一个描述符 read 长时间处于等待数据而使程序阻塞。 轮询的缺点是浪费太多 CPU 时间。大多数时候我们没有数据可读，但是还是用了 read 这个系统调用，使用系统调用时会从用户态切换到内核态。而大多数情况下我们调用 read，然后陷入内核态，内核发现这个描述符没有准备好，然后切换回用户态并且只得到 EAGAIN （errorno 被设置为 35），做的是无用功。描述符非常多的时候，每次的切换过程就是巨大的浪费。 所以，需要 I/O 多路复用。I/O 多路复用通过使用一个系统函数，同时等待多个描述符的可读、可写状态。 为了达到这个目的，我们需要做的是：建立一个描述符列表，以及我们分别关心它们的什么事件（可读还是可写还是发生例外情况）；调用一个系统函数，直到这个描述符列表里有至少一个描述符关联的事件发生时，这个函数才会返回。 select, poll, epoll 就是这样的系统函数。 select我们可以在所有 POSIX 兼容的系统里使用 select 函数来进行 I/O 多路复用。我们需要通过 select 函数的参数传递给内核的信息有： 我们关心哪些描述符 我们关心它们的什么事件 我们希望等待多长时间 select 的返回时，内核会告诉我们： 可读的描述符的个数 哪些描述符发生了哪些事件 123456#include &lt;sys/select.h&gt;int select(int maxfdp1, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1 maxfdp1 意思是 “max file descriptor plus 1” ，就是把你要监视的所有文件描述符里最大的那个加上 1 。（它实际上决定了内核要遍历文件描述符的次数，比如你监视了文件描述符 5 和 20 并把 maxfdp1 设置为 21 ，内核每次都会从描述符 0 依次检查到 20。） 中间的三个参数是你想监视的文件描述符的集合。可以把 fd_set 类型视为 1024 位的二进制数，这意味着 select 只能监视小于 1024 的文件描述符（1024 是由 Linux 的 sys/select.h 里 FD_SETSIZE 宏设置的值）。在 select 返回后我们通过 FD_ISSET 来判断代表该位的描述符是否是已准备好的状态。 最后一个参数是等待超时的时长：到达这个时长但是没有任一描述符可用时，函数会返回 0 。 用一个代码片段来展示 select 的用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态// 初始化两个 fd_set 以及 timevalfd_set read_set, write_set;FD_ZERO(read_set);FD_ZERO(write_set);timeval t;t.tv_sec = 5; // 超时为 5 秒t.tv_usec = 0; // 加 0 微秒// 设置好两个 fd_setint fd1 = 3;int fd2 = 4;int fd3 = 5;int maxfdp1 = 5 + 1;FD_SET(fd1, &amp;read_set);FD_SET(fd2, &amp;read_set);FD_SET(fd2, &amp;write_set);FD_SET(fd3, &amp;write_set);// 准备备用的 fd_setfd_set r_temp = read_set;fd_set w_temp = write_set;while(true)&#123; // 每次都要重新设置放入 select 的 fd_set read_set = r_temp; write_set = w_temp; // 使用 select int n = select(maxfdp1, &amp;read_set, &amp;write_set, NULL, &amp;t); // 上面的 select 函数会一直阻塞，直到 // 3, 4 可读以及 4, 5 可写这四件事中至少一项发生 // 或者等待时间到达 5 秒，返回 0 for(int i=0; i&lt;maxfdp1 &amp;&amp; n&gt;0; i++)&#123; if(FD_ISSET(i, &amp;read_set))&#123; n--; if(i==fd1) prinf(\"描述符 3 可读\"); if(i==fd2) prinf(\"描述符 4 可读\"); &#125; if(FD_ISSET(i, &amp;write_set))&#123; n--; if(i==fd2) prinf(\"描述符 3 可写\"); if(i==fd3) prinf(\"描述符 4 可写\"); &#125; &#125; // 上面的 printf 语句换成对应的 read 或者 write 函数就 // 可以立即读取或者写入相应的描述符而不用等待&#125; 可以看到，select 的缺点有： 默认能监视的文件描述符不能大于 1024，也代表监视的总数不超过1024。即使你因为需要监视的描述符大于 1024 而改动内核的 FD_SETSIZE 值，但由于 select 是每次都会线性扫描整个fd_set，集合越大速度越慢，所以性能会比较差。 select 函数返回时只能看见已准备好的描述符数量，至于是哪个描述符准备好了需要循环用 FD_ISSET 来检查，当未准备好的描述符很多而准备好的很少时，效率比较低。 select 函数每次执行的时候，都把参数里传入的三个 fd_set 从用户空间复制到内核空间。而每次 fd_set 里要监视的描述符变化不大时，全部重新复制一遍并不划算。同样在每次都是未准备好的描述符很多而准备好的很少时，调用 select 会很频繁，用户/内核间的的数据复制就成了一个大的开销。 还有一个问题是在代码的写法上给我一些困扰的，就是每次调用 select 前必须重新设置三个 fd_set。 fd_set 类型只是 1024 位的二进制数（实际上结构体里是几个 long 变量的数组；比如 64 位机器上 long 是 64 bit，那么 fd_set 里就是 16 个 long 变量的数组），由一位的 1 和 0 代表一个文件描述符的状态，但是其实调用 select 前后位的 1/0 状态意义是不一样的。 先讲一下几个对 fd_set 操作的函数的作用：FD_ZERO 把 fd_set 所有位设置为 0 ；FD_SET 把一个位设置为 1 ；FD_ISSET 判断一个位是否为 1 。 调用 select 前：我们用 FD_ZERO 把 fd_set 先全部初始化，然后用 FD_SET 把我们关心的代表描述符的位设置为 1 。我们这时可以用 FD_ISSET 判断这个位是否被我们设置，这时的含义是我们想要监视的描述符是否被设置为被监视的状态。 调用 select 时：内核判断 fd_set 里的位并把各个 fd_set 里所有值为 1 的位记录下来，然后把 fd_set 全部设置成 0 ；一个描述符上有对应的事件发生时，把对应 fd_set 里代表这个描述符的位设置为 1 。 在 select 返回之后：我们同样用 FD_ISSET 判断各个我们关心的位是 0 还是 1 ，这时的含义是，这个位是否是发生了我们关心的事件。 所以，在下一次调用 select 前，我们不得不把已经被内核改掉的 fd_set 全部重新设置一下。 select 在监视大量描述符尤其是更多的描述符未准备好的情况时性能很差。《Unix 高级编程》里写，用 select 的程序通常只使用 3 到 10 个描述符。 pollpoll 和 select 是相似的，只是给的接口不同。 1234#include &lt;poll.h&gt;int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1 fdarray 是 pollfd 的数组。pollfd 结构体是这样的： 12345struct pollfd &#123; int fd; // 文件描述符 short events; // 我期待的事件 short revents; // 实际发生的事件：我期待的事件中发生的；或者异常情况&#125;; nfds 是 fdarray 的长度，也就是 pollfd 的个数。 timeout 代表等待超时的毫秒数。 相比 select ，poll 有这些优点：由于 poll 在 pollfd 里用 int fd 来表示文件描述符而不像 select 里用的 fd_set 来分别表示描述符，所以没有必须小于 1024 的限制，也没有数量限制；由于 poll 用 events 表示期待的事件，通过修改 revents 来表示发生的事件，所以不需要像 select 在每次调用前重新设置描述符和期待的事件。 除此之外，poll 和 select 几乎相同。在 poll 返回后，需要遍历 fdarray 来检查各个 pollfd 里的 revents 是否发生了期待的事件；每次调用 poll 时，把 fdarray 复制到内核空间。在描述符太多而每次准备好的较少时，poll 有同样的性能问题。 epollepoll 是在 Linux 2.5.44 中首度登场的。不像 select 和 poll ，它提供了三个系统函数而不是一个。 epoll_create 用来创建一个 epoll 描述符：1234#include &lt;sys/epoll.h&gt;int epoll_create(int size);// 返回值：epoll 描述符 size 用来告诉内核你想监视的文件描述符的数目，但是它并不是限制了能监视的描述符的最大个数，而是给内核最初分配的空间一个建议。然后系统会在内核中分配一个空间来存放事件表，并返回一个 epoll 描述符，用来操作这个事件表。 epoll_ctl 用来增/删/改内核中的事件表：123int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 返回值：成功时返回 0 ，失败时返回 -1 epfd 是 epoll 描述符。 op 是操作类型（增加/删除/修改）。 fd 是希望监视的文件描述符。 event 是一个 epoll_event 结构体的指针。epoll_event 的定义是这样的： 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; // 我期待的事件 epoll_data_t data; // 用户数据变量&#125;; 这个结构体里，除了期待的事件外，还有一个 data ，是一个 union，它是用来让我们在得到下面第三个函数的返回值以后方便的定位文件描述符的。 epoll_wait 用来等待事件1234int epoll_wait(int epfd, struct epoll_event *result_events, int maxevents, int timeout);// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1 epfd 是 epoll 描述符。 result_events 是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义。 maxevents 是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数。 timeout 是等待超时的毫秒数。 用一个代码片段来展示 epoll 的用法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态/* 通过 epoll_create 创建 epoll 描述符 */int epfd = epoll_create(4);int fd1 = 3;int fd2 = 4;int fd3 = 5;/* 通过 epoll_ctl 注册好四个事件 */struct epoll_event ev1;ev1.events = EPOLLIN; // 期待它的可读事件发生ev1.data = fd1; // 我们通常就把 data 设置为 fd ，方便以后查看epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev1); // 添加到事件表struct epoll_event ev2;ev2.events = EPOLLIN;ev2.data = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev2);struct epoll_event ev3;ev3.events = EPOLLOUT; // 期待它的可写事件发生ev3.data = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev3);struct epoll_event ev4;ev4.events = EPOLLOUT;ev4.data = fd3;epoll_ctl(epfd, EPOLL_CTL_ADD, fd3, &amp;ev4);/* 通过 epoll_wait 等待事件 */# DEFINE MAXEVENTS 4struct epoll_event result_events[MAXEVENTS];while(true)&#123; int n = epoll_wait(epfd, &amp;result_events, MAXEVENTS, 5000); for(int i=0; i&lt;n; n--)&#123; // result_events[i] 一定是 ev1 到 ev4 中的一个 if(result_events[i].events&amp;EPOLLIN) printf(\"描述符 %d 可读\", result_events[i].fd); else if(result_events[i].events&amp;EPOLLOUT) printf(\"描述符 %d 可写\", result_events[i].fd) &#125;&#125; 所以 epoll 解决了 poll 和 select 的问题： 只在 epoll_ctl 的时候把数据复制到内核空间，这保证了每个描述符和事件一定只会被复制到内核空间一次；每次调用 epoll_wait 都不会复制新数据到内核空间。相比之下，select 每次调用都会把三个 fd_set 复制一遍；poll 每次调用都会把 fdarray 复制一遍。 epoll_wait 返回 n ，那么只需要做 n 次循环，可以保证遍历的每一次都是有意义的。相比之下，select 需要做至少 n 次至多 maxfdp1 次循环；poll 需要遍历完 fdarray 即做 nfds 次循环。 在内部实现上，epoll 使用了回调的方法。调用 epoll_ctl 时，就是注册了一个事件：在集合中放入文件描述符以及事件数据，并且加上一个回调函数。一旦文件描述符上的对应事件发生，就会调用回调函数，这个函数会把这个文件描述符加入到就绪队列上。当你调用 epoll_wait 时，它只是在查看就绪队列上是否有内容，有的话就返回给你的程序。select() poll() epoll_wait() 三个函数在操作系统看来，都是睡眠一会儿然后判断一会儿的循环，但是 select 和 poll 在醒着的时候要遍历整个文件描述符集合，而 epoll_wait 只是看看就绪队列是否为空而已。这是 epoll 高性能的理由，使得其 I/O 的效率不会像使用轮询的 select/poll 随着描述符增加而大大降低。 注 1 ：select/poll/epoll_wait 三个函数的等待超时时间都有一样的特性：等待时间设置为 0 时函数不阻塞而是立即返回，不论是否有文件描述符已准备好；poll/epoll_wait 中的 timeout 为 -1，select 中的 timeout 为 NULL 时，则无限等待，直到有描述符已准备好才会返回。 注 2 ：有的新手会把文件描述符是否标记为阻塞 I/O 等同于 I/O 多路复用函数是否阻塞。其实文件描述符是否标记为阻塞，决定了你 read 或 write 它时如果它未准备好是阻塞等待，还是立即返回 EAGAIN ；而 I/O 多路复用函数除非你把 timeout 设置为 0 ，否则它总是会阻塞住你的程序。 注 3 ：上面的例子只是入门，可能是不准确或不全面的：一是数据要立即处理防止丢失；二是 EPOLLIN/EPOLLOUT 不完全等同于可读可写事件，具体要去搜索 poll/epoll 的事件具体有哪些；三是大多数实际例子里，比如一个 tcp server ，都会在运行中不断增加/删除的文件描述符而不是记住固定的 3 4 5 几个描述符（用这种例子更能看出 epoll 的优势）；四是 epoll 的优势更多的体现在处理大量闲连接的情况，如果场景是处理少量短连接，用 select 反而更好，而且用 select 的代码能运行在所有平台上。","categories":[{"name":"编程","slug":"编程","permalink":"https://jeff.wtf/categories/编程/"}],"tags":[]},{"title":"老人的囤积综合征","slug":"diogenes","date":"2016-12-23T06:59:09.000Z","updated":"2019-01-28T07:31:30.734Z","comments":true,"path":"2016/12/diogenes/","link":"","permalink":"https://jeff.wtf/2016/12/diogenes/","excerpt":"","text":"囤积症或储物症（英文： Compulsive hoarding，或强迫性囤积症、病态性囤积症、弃置恐惧症），一种强迫行为，过度性地收购或收集物件，即使是不值钱、有危险性或不卫生的物品。 ——维基百科 第欧根尼综合症，又名肮脏混乱综合症或众议院综合征。主要出现在老年人上，有时伴随老年痴呆症。 ——百度百科 我第一次听说这种疾病的时候是很恐慌的。因为我的奶奶有类似这些症状的行为。 我一直把老人舍不得扔掉东西、甚至主动囤积的行为解释为老一辈人看到物品的价值和我们不一样。比如我看到这是一盘吃不完的剩菜，价值10块钱，扔掉没什么大不了，应该被扔掉了；老人看到的却不一样，他们看到，这是一盘剩菜，它的作料长在地里，它的食材在另一个地方被养殖，盘底的植物油是被压榨出来的。 他们站在这个立场上，对一个物品的价值判断和我们完全不同。主动囤积也是这个原因。 后来，我有了新的猜测。虽然有点悲哀，但它是可能的。 这个理由同样是由于立场带来的价值判断的区别。审视一个物品的时候，老人和我们看到这个物品剩余的价值不同。 我们看到一盘剩菜，想到的是：没有人会需要它了，它应该被扔掉。老人看到一盘剩菜的时候，想到的是：它还有部分可以被食用，它应该被留下。 这是立场问题，因为老人就像一盘剩菜。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]},{"title":"看操作系统有感：战略上的勤奋","slug":"think-os","date":"2016-12-20T08:15:02.000Z","updated":"2019-01-28T07:31:30.744Z","comments":true,"path":"2016/12/think-os/","link":"","permalink":"https://jeff.wtf/2016/12/think-os/","excerpt":"","text":"前天看一本 Gitbook ，说操作系统有四个基本抽象：中断、进程、虚存、文件，它们是操作系统设计的基础。 为什么一定要有这四个基本抽象？我想谈谈自己浅薄的理解以及感想。 为什么一定要有进程的存在？目的大家都知道：为了让单个处理机同时处理多个有独立功能的任务、尽量提高处理机的利用率。 如果大家没有选择让操作系统来统筹调度多任务的话，计算机行业会选择什么样的替代方案？ 我能想到的方案是用更多的处理机，一个处理机当然只做一个任务。发展到今天，可能会是这样的情况：今天我去买了 intel 最新的 256 核处理器，可以同时处理更多的任务；新的单机游戏 GTA5 要求至少128核处理器才能跑起来，因为它有 80 个线程在工作。诸如此类。 但是计算机行业的选择并不是这样！我们把复杂的逻辑加在操作系统上，发明进程这个概念，让单个处理机同时处理更多的任务。 有句话经常被用来嘲讽不停“学习”却成绩差的“笨”学生：不要用战术上的勤奋，掩饰战略上的懒惰。计算机的发展正是如此。很多问题有简单粗暴的解决办法也有复杂巧妙的解决办法。简单粗暴比如进程没有被设计出来，大家需要依赖行业发展出多核处理器；比如项目性能不行，我们要依赖加钱加机器。复杂巧妙则是在现有的技术条件下对运作方式进行改良。 假如计算机行业的发展是简单粗暴的，那么虚存、文件系统都是这样： 虚存的存在是为了实现三件事：让内存看起来更大、让程序使用看起来连续的地址空间、让各个程序使用的内存互相隔离。如果没有用虚存这个方案，简单粗暴的“操作系统”将会：给程序分配连续固定且足够大的空间。这样利用率相比现在低了很多，不够的时候怎么办？加内存。 文件系统也是如此，简单粗暴的“操作系统”让数据连续摆放，没有分块这种事情存在，你看到的数据的顺序和物理上一致。不够的时候怎么办，加硬盘。 计算机行业用战略上的勤奋，让我们有了今天这样复杂的操作系统和廉价的个人电脑。 用户态线程把目光向上加一层。 我自己的操作系统课本里有“用户态线程”这个概念，解释为不能被操作系统感知的线程，和我们常说的“线程”有很大不同。按照这个概念，协程就是用户态线程。每个协程有自己独立的上下文，可以在当中被切入切出。不过这个调度不是由操作系统来做的（操作系统根本无法感知），Python 的协程让用户来做显式的切换，Go 语言则是在语言级别有一个调度器。 再抽象一点，用到回调的编程方法时，系统向程序通知一个事件，程序让出当前的顺序的代码的执行权，进入设置好的回调函数的栈上下文，也是一个独立的“用户态线程”。只不过它的入口和出口固定了。 WEB 后端编程喜欢用多线程，来一个请求，就开启一个独立的线程。开一个新线程是很简单的事，当它阻塞的时候就让它阻塞好了，因为操作系统很聪明，它发现这个线程阻塞了，然后会把处理机的执行权和上下文切换为其它线程。但是量足够大时，线程的创建和销毁是很大的开销，因为这两件事要经历内核态和用户态的切换。于是我们有 I/O 多路复用，我们有线程池，减少这个开销。但是量再大时，到 C10K 问题的出现，则是线程的切换成本已经成为了巨大的负担。 我认为不停地开线程，就是战略上的懒惰。使用协程（或者用户态线程）则是战略上的勤奋，它把切换的工作交给了自己而不是操作系统。当我执行一个网络或者文件操作时，我知道马上会是阻塞的，于是标记一下，然后立马切到其他上下文中执行其他协程；这个操作标记完成时，再在其他协程让出执行权时切换回来。这样，协程不需要像系统线程一样保有优先级以及多核的负载均衡等信息，也不需要在切换协程时在内核态和用户态之间切换。复杂了自己程序的逻辑，节省了负担。 不用战术上的勤奋，掩饰战略上的懒惰。“战术上的勤奋”是各种意义上资源的浪费，战略上的勤奋则是资源的节约。所以今天高科技的各种廉价，感谢商业的法则，感谢计算机行业的人才，也期待 Go 语言以及各种自带“用户态线程”语言的前途。","categories":[{"name":"计算机","slug":"计算机","permalink":"https://jeff.wtf/categories/计算机/"}],"tags":[]},{"title":"局部变量在Python闭包中遇到的一些麻烦","slug":"local-var-in-python-closure","date":"2016-11-20T06:08:30.000Z","updated":"2019-01-28T07:31:30.736Z","comments":true,"path":"2016/11/local-var-in-python-closure/","link":"","permalink":"https://jeff.wtf/2016/11/local-var-in-python-closure/","excerpt":"","text":"Python作用域的一些麻烦Python 的作用域有这样的规则，你在内部的局部作用域里，仅仅使用外部的变量是允许的，但是改变这个引用本身是不被允许的。 123456def outer(): v = 2 def inner(): t = v + 1 print(t) return inner 上面的代码是没有错误的， v 被认为是外部作用域的变量，引用它是可以的。 1234567def outer(): v = 2 def inner(): v = 3 v += 1 print(v) return inner 上面也是没有错误的， v 被定义为内部作用域的变量，对它的操作和外部的 v 无关。 但是，这样是错误的： 1234567def outer(): v = 2 def inner(): t = v + 1 print(t) v = t return inner 上面的例子里，执行t = v + 1这一行时会报错，因为这个作用域里有改变 v 本身的操作：v = t，所以 v 被认为是一个内部的变量，而我们并不能在这个作用域里找到它的定义。 这个时候需要使用 nonlocal 关键字，把 v 声明为外部作用域的变量： （ Python2 并没有 nonlocal 关键字，所以没有办法在内部的局部作用域改变外部的局部作用域的变量本身。当然可以使用可变对象如 list 来模拟这样的效果，但你仍旧不能修改这个引用本身指向的对象。） （同理，局部作用域里引用全局变量是可以的，但是当你要改变它时，需要加上global关键字。） 例1： 12345678def outer(): v = 2 def inner(): nonlocal v t = v + 1 print(t) v = t return inner 例2： 1234567def outer(v): # 传入的参数 v 同样是 outer 作用域的变量 def inner(): nonlocal v # 如果你打算改变它，也需要加上 nonlocal 关键字 t = v + 1 print(t) v = t return inner 如果你熟悉 javascript 或者其他可以使用闭包的语言，会因为 Python 处理作用域的机制遇到麻烦。 下面是对于几种情况的分析先来看第一种情况，内部作用域仅仅使用外部变量而不改变它： 这种是一种正确的情况。 从 print 出的v.__str__可以看到 v 的地址是0x5C7D5920；a.__closure__是 a 包含的cell对象的元组，可以看到里面只有一个cell对象，并且持有一个 int 类型的对象，地址同样是0x5C7D5920。 （一个 cell 对象用来保存一个在多个作用域中被引用的变量的值。例如这里的 v 在 outer 中被引用，也在inner中被引用，它就会被保存在一个 cell 对象里。） 后一张图是dis.dis(a)得到的字节码。 LOAD_DEFRED是从cell中得到对象的内容并 push 进栈。也就是说，是从 cell 里得到的 v 值。 第二种情况，内部作用域改变外部变量： 这种情况调用a()时会报错。 a.__closure__没有内容，也就是说，它并不认为 inner 里引用了 outer 作用域的变量，所以并没有创建 cell 来存储任何变量。 看字节码。第一行就是LOAD_FAST，把变量 v 的值压入栈。而在此之前 v 并没有被定义，于是会在这里报错。 第三种情况，使用 nonlocal 关键字： a.__closure__有一个 cell 对象，且它持有的一个对象的地址和print看到的 v 的地址相同。 字节码里的 20 和 23 开头的这两行是v = t的步骤。去掉这个，字节码以及a.__closure__都和第一种情况完全相同。也就是说，内部的 v 是用一个 cell 对象储存起来、和外部 v 同样的对象。","categories":[{"name":"编程","slug":"编程","permalink":"https://jeff.wtf/categories/编程/"}],"tags":[]},{"title":"通过弹幕信息得到Bilibili用户的ID","slug":"get-bilibili-user","date":"2016-11-19T13:15:10.000Z","updated":"2019-01-28T07:31:30.734Z","comments":true,"path":"2016/11/get-bilibili-user/","link":"","permalink":"https://jeff.wtf/2016/11/get-bilibili-user/","excerpt":"","text":"当你打开一个视频页面的源代码，可以找到某一行，在播放器的位置，有一个 cid 参数。 B 站发送的请求里也可以看到弹幕请求： 请求弹幕的地址是http://comment.bilibili.com/看到的cid.xml 弹幕信息的内容：&lt;d p=&quot;时间,模式,字体大小,颜色,时间戳,弹幕池,？？？,弹幕ID&quot;&gt;内容&lt;/d&gt;。 从这里并不能看到用户的 ID 。上面？？？的部分应该是用户 ID 的某种 hash 。 测试一下。我的B站空间是 http://space.bilibili.com/4764287/ ，其中 4764287 是我的 ID 。在弹幕列表找到自己发过的弹幕，？？？部分是 01da63f0 。 经过一些测试，最后发现 4764287 经过 CRC32b hash 结果是 f063da01 ，而储存在弹幕信息里的值是 01da63f0 。也就是说，弹幕信息？？？部分是用户 ID CRC32b 之后得到的结果按每两位一组倒序排列的结果。 所以，已知弹幕信息，想逆向找到发弹幕的用户，需要有所有用户 ID 的 CRC32b 彩虹表（现在 B 站用户 ID 为 1 到接近 60, 000, 000）即可。 而且已经有人做了这件事：https://danmu.fuckbilibili.com/","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jeff.wtf/categories/随笔/"}],"tags":[]}]}