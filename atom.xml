<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>善良的杰夫</title>
  
  
  <link href="https://jeff.wtf/atom.xml" rel="self"/>
  
  <link href="https://jeff.wtf/"/>
  <updated>2022-10-29T16:43:36.924Z</updated>
  <id>https://jeff.wtf/</id>
  
  <author>
    <name>Jeff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浴室沉思：Debug 什么问题最爽</title>
    <link href="https://jeff.wtf/2022/10/funny-debug/"/>
    <id>https://jeff.wtf/2022/10/funny-debug/</id>
    <published>2022-10-29T16:36:00.000Z</published>
    <updated>2022-10-29T16:43:36.924Z</updated>
    
    <content type="html"><![CDATA[<p>毕业已经四年多了，想想我 debug 过试过或失败的大小问题应该数不胜数。浴室沉思：debug 什么样的问题是最爽的？</p><hr><p>我对<strong>复杂问题</strong>有两种归类：一种类似网游、竞技游戏，规则复杂、设定丰富、不确定因素更多，好比现实中的混沌理论；另一种类似围棋、传送门这种游戏，规则有限、设定极少、谜面完全确定，但解法可以很复杂，好比真空中的球形鸡。</p><p>两个例子：</p><ol><li>为什么删掉十年前没有被任何地方引用的另一个项目的代码，看起来毫无影响的项目的新代码就坏掉了？</li><li>某处限制了64KB大小，但我们的数据即使用常用的二进制编码格式仍然可能超过这个大小；我们有 5% 的数据可能会超过这个大小，怎么改代码是更合理的？</li></ol><p>后者显然求解起来更爽，我也更喜欢做后者描述的问题。但解开以后的成就感呢？我只能说我现在印象深刻的问题好像都是前者。</p><hr><p>另一个很重要的事情是，<strong>和别人讲</strong>这个问题的时候什么类型的问题更有成就感？</p><blockquote><p>它确实是「爽」的重要组成部分</p></blockquote><p>我解决过一些奇奇怪怪的并发先后问题、难复现的用户场景问题、奇葩的边界条件问题，但这些都不是我乐意和别人说的东西。</p><p>说这些东西的成就感不会很高，是因为这种问题有时就是蒙出来的（即使我会觉得自己蒙的很有艺术性），但大家都能蒙。就算我给别人描述其中的逻辑有多复杂、层级有多深，或许对方只会觉得「屎山代码嘛，我公司代码库里还有 20 年前没有人敢动的代码呢」。</p><hr><p>如果有人问「你解决过的最有意思的问题是什么」，我通常会回答下面中的一个。</p><h2 id="一、欧洲用户问题"><a href="#一、欧洲用户问题" class="headerlink" title="一、欧洲用户问题"></a>一、欧洲用户问题</h2><h3 id="背景（已简化）"><a href="#背景（已简化）" class="headerlink" title="背景（已简化）"></a>背景（已简化）</h3><p>扇贝单词是一个背单词 APP；一个重要功能是完成当天的学习任务后，当天可以打卡；用户都是在自己的当地时区的自然天打卡。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一些用户某天开始突然不能打卡</p><h3 id="一筹莫展"><a href="#一筹莫展" class="headerlink" title="一筹莫展"></a>一筹莫展</h3><p>收集了一些用户反馈，发现他们都是欧洲的用户；而且都在自己当地时区的 0 点附近尝试打卡失败；也就是说用户在当地时间并没有度过当天 24 点，但我们系统认为他已经度过了当天 24 点，不允许打前一天的卡。</p><p>第一直觉是时区相关的代码逻辑出问题，检查后发现这部分代码并没有人动过。</p><p>第二直觉就是和夏冬令时有关，恰好出问题前几天欧洲从夏令时切到冬令时。但：时区相关的代码没有人动过；往年夏冬令时切换并没有出现问题；美国用户也不少，美国很多州也有夏冬令时，却完全正常。</p><h3 id="欧洲特例？"><a href="#欧洲特例？" class="headerlink" title="欧洲特例？"></a>欧洲特例？</h3><p>就在一筹莫展之际，我突然想到几年前看过一个新闻，印象中欧盟通过了一项决议，会在 2020 年取消夏冬令时。那是不是意味着有可能他们的法令执行了，代码里的时区信息却没有更新？</p><p>但是：</p><ul><li>当时使用的是最新的 go 1.14，彼时 go 语言还没有加入 tzdata 标准库</li><li>所以代码里的时区信息来源，是在每次打包镜像时 alpine 里安装的 tzdata；我们安装的 tzdata 已经是最新版，要是有问题全世界用到 tzdata 的服务应该都爆炸了才对</li></ul><p>而且：</p><ul><li>重新搜索这个新闻，发现欧盟已经取消这个「2020 年取消夏冬令时」的决议了。</li></ul><p>这下更怪了。</p><h3 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h3><p>那是不是有可能，现实中的欧盟已经取消执行了，tzdata 却还是按照原本的决议执行了呢？</p><p>nonono，还是一样的问题：如果 tzdata 的数据不对，全世界都应该爆炸了，不应该只有我们在抱怨。</p><h3 id="尝试复现"><a href="#尝试复现" class="headerlink" title="尝试复现"></a>尝试复现</h3><p>要确定是时区相关的问题，还是需要复现证明一下。似乎本地安装最新版 tzdata，用 go 写一个例子打印欧洲某地的时区尝试复现一下就好。</p><p>但复现成功是一个非常偶然的状况。</p><p>我当时在本地运行打印时间的代码，一切都是正确符合预期的；直到（已经不记得是怎么发生的了，大概是同事提醒）尝试在 alpine 容器里编译同样的代码，执行，打印出来的时间却和当地现实时间差一小时！</p><p>在 tzdata 版本一模一样的状况下！</p><p>复现成功以后一切就水到渠成。我们做更多测试，来判断是编译期的问题还是运行期的问题、是不是 apline 的安装问题等等。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>alpine 上安装的 tzdata 里的信息是正确的；它在欧盟开始决议后更新了信息；欧盟取消决议后也附加上了取消决议的信息。</p><p>实际问题是，alpine 上的 tzdata 包用了和其他地方不一样的格式（或语法？已经记不太清了）。这种取消再取消的格式比较新，当时的 go 1.14 能读取到「在 2020 年取消夏冬令时」这个信息，但读不出来「取消「在 2020 年取消夏冬令时」」这个信息。导致实际在 alpine 环境里，go 1.14 的程序认为这项法令已经执行了。</p><p>最后的解决方案是：</p><ul><li>把 base image 换成了 ubuntu，tzdata 版本没变，一切运行正常</li><li>go 1.15 当时马上就要出了，这个新格式也能正常读取；有一些人反馈以后（很多天），给 1.14 增加了一个小版本 backport 解决了这个问题</li><li>go 1.15 自带了 tzdata。但我想，用半年一更新的语言标准库带的时区信息怎么跟得上变幻莫测的现实世界呢？</li></ul><blockquote><p>PS: 之所以在「背景」这一节加上了已简化三个字，是因为实际后端逻辑是：允许用户在连续背单词超过当地 0 点但不超过 1 点时，仍然可以打前一天的卡……</p><p>加上这个逻辑以后，是不是觉得 debug 的复杂度上去了一截……</p></blockquote><h2 id="二、有概率发生的性能问题"><a href="#二、有概率发生的性能问题" class="headerlink" title="二、有概率发生的性能问题"></a>二、有概率发生的性能问题</h2><p><strong>由于写到这里我已经觉得太长想摆烂了，下面我就摆烂了</strong></p><p>这个问题的结论是阿里云同样规格的某些云服务器，在一些条件下单核性能会比其他低 30%</p><h2 id="三、CI-环境里编译-go-代码特别慢"><a href="#三、CI-环境里编译-go-代码特别慢" class="headerlink" title="三、CI 环境里编译 go 代码特别慢"></a>三、CI 环境里编译 go 代码特别慢</h2><p>这个问题的结论是 CI 环境里的机器的 CPU 没有 AVX 指令集；go 代码里引入了 C++ 代码一起编译，其中一些使用 AVX 指令会编译的非常快，没有就非常慢。</p><h2 id="四、未解之谜"><a href="#四、未解之谜" class="headerlink" title="四、未解之谜"></a>四、未解之谜</h2><p>一段 go 代码会声明读写一些数组，它们的生命周期就是一个请求的生命周期；这段代码在生产环境会内存泄露，但很慢，一天几十 M，但永远不会下降直到重启。</p><p>使用 go 语言的 profile 和 metrics 采集观测不到，但观测操作系统里这个进程的 RSS 指标会看到。</p><p>本地测试非常多次完全无法复现状况，比生产环境更大的暴力压测都不行（或者说有时似乎复现了，但解决方案放到生产环境并没有用）。</p><p>已知的：</p><ul><li>有一些数组可能很长几十万字节，有一些则很短；不论我们一开始声明很长的变量，或是一个个 append 都会发生内存泄漏</li><li>代码逻辑里不存在全局变量或者其他导致泄露的问题</li><li>在 go 程序里手动释放内存、标记 madvdontneed 等等，问题依然存在（当时已经在使用 1.16）</li><li>确认了我们的 go 程序会执行 Linux 的 MADV_DONTNEED 指令而不是 MADV_FREE、更新了宿主机的 Linux 内核版本</li></ul><p>怀疑是 go 的内存模型和 linux 的某些机制导致的泄露（碎片？），但彼时已经 debug 超过一周仍然没有成效，而且问题似乎已经过于底层触及了我的知识盲区。最终仅仅是限制了数组的大小，逻辑完全不变的情况下，问题解决，再也没有内存泄露。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;毕业已经四年多了，想想我 debug 过试过或失败的大小问题应该数不胜数。浴室沉思：debug 什么样的问题是最爽的？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我对&lt;strong&gt;复杂问题&lt;/strong&gt;有两种归类：一种类似网游、竞技游戏，规则复杂、设定丰富、不确定因素更多，好比现实中的</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>需求：给网站绑一万个域名，自动生成 HTTPS 证书</title>
    <link href="https://jeff.wtf/2022/08/tens-of-thousands-of-domains-over-https/"/>
    <id>https://jeff.wtf/2022/08/tens-of-thousands-of-domains-over-https/</id>
    <published>2022-08-18T13:43:23.000Z</published>
    <updated>2022-08-18T16:40:10.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先解决标题党的问题"><a href="#先解决标题党的问题" class="headerlink" title="先解决标题党的问题"></a>先解决标题党的问题</h1><blockquote><p>实际需求和标题有些差异，但很难在一个短标题里描述出完整的需求。先把这个标题相关的问题解决好了。</p></blockquote><p>如果是一万个已知的域名，想要给他们批量签证书：例如已经存在一个域名列表（听起来有点灰产）。那么需要做的应该是：</p><ol><li>用脚本批量给他们做好 DNS 解析<ul><li>比如都解析到 IP <code>w.x.y.z</code></li></ul></li><li>在 <code>w.x.y.z</code> 起服务，用来做 <a href="https://letsencrypt.org/docs/challenge-types/#http-01-challenge">HTTP Challenge</a><ul><li>启动一个 <a href="https://cert-manager.io/">cert-manager</a>，把一万个域名灌给它，让他开始签证书</li></ul></li><li>网关监听 443，并挂上 cert-manager 产生的公私钥<ul><li>取决于网关的功能，如果网关要求写清楚每一个域名，用脚本自动生成一万个路由配置即可</li></ul></li></ol><p>听起来很不优雅，但「又不是不能用.jpg」；毕竟它只是个一次性的任务，能离线完成的任务当然是离线完成更安全。</p><h1 id="真实的需求"><a href="#真实的需求" class="headerlink" title="真实的需求"></a>真实的需求</h1><p>真实的需求是：</p><ul><li><a href="https://xlog.app/">xlog</a> 是一个基于 crossbell 链的写作平台</li><li>用户可以产生自定义的二级域名如 <code>jeff.xlog.app</code></li><li><strong>并且，用户可以绑定自己的任意域名到自己的主页</strong><ul><li>例如 <code>x.jeff.wtf</code></li></ul></li><li>用户绑定好、DNS 指向 xlog 以后，可以自动签发 HTTPS 证书；访问时全程 HTTPS</li></ul><h2 id="cert-manager❎"><a href="#cert-manager❎" class="headerlink" title="cert-manager❎"></a>cert-manager❎</h2><p>首先还是来看看老办法 cert-manager 。</p><p>顺着上面的思路，一个很直接的想法就是：</p><ol><li>用户在 xlog.app 面板操作绑定完成时，把这个想绑定的域名发给 cert-manager，让它开始签发证书</li><li>得到证书以后，修改网关配置并 reload （取决于使用的网关）</li><li>用户来访问时，网关已经拥有了签好的证书，于是直接建立了 HTTPS 链接</li></ol><p>除了 <strong>业务（xlog）</strong> 和 <strong>基建（cert-manager）</strong> 有一点小小的耦合以外，貌似没有什么大问题。</p><h3 id="哪里不对劲？"><a href="#哪里不对劲？" class="headerlink" title="哪里不对劲？"></a><span style="color:green">哪里不对劲？</span></h3><p>不对劲的地方在于，用户修改 DNS 解析这一步在哪里？</p><p>上面这个方案错误的地方是<strong>签发的时机</strong>：</p><ul><li>如果用户还没有解析完成，cert-manager 根本无法通过 HTTP-Challenge</li><li>cert-manager 怎么知道域名已经解析过来了？<ul><li>最简单的答案是：如果有一个 <code>Host: 想绑的域名</code> 的请求发到了 xlog 的地址，这时我们认为这是用户的第一次访问，此时已经解析完成<ul><li>（虽然很容易作假，但我们并不会损失什么）</li></ul></li></ul></li></ul><p>所以签发的时机只能是等到用户来请求。如果等到请求已经到了，我们再去做这些事：</p><ul><li>发域名给 cert-manager 签证书</li><li>签完证书改配让网关 reload<ul><li>如果为了高可用，网关数量大于一，则是等所有网关 reload 完成</li></ul></li></ul><p>这就意味着用户的头几个（或者更多）请求一定是失败的。即使用一点小小的优化比如定时循环尝试证书签发，这个时间也不太可控。</p><h2 id="为什么只能让网关来发起签证书？"><a href="#为什么只能让网关来发起签证书？" class="headerlink" title="为什么只能让网关来发起签证书？"></a>为什么只能让网关来发起签证书？</h2><p>作为对上面的补充说明，可以想象这样一个场景：</p><ol><li>用户在 xlog 面板绑定了自己的域名</li><li>但他一直没有改 DNS 解析</li><li>直到某一天，他突然想起来，于是去做了解析</li><li>解析生效后，他访问网站，此时应该正常建立 HTTPS 链接</li></ol><p>如果使用类似「定时尝试签发证书」这样的方案，大量资源被浪费；而且这是一种很明显可以被攻击的漏洞：我只要不断绑定域名，但不做解析，服务器就会有无限的资源被浪费。</p><p>所以，触发签发的时机必须是 <strong>网关第一次收到这个域名作为 Host 的请求</strong>。</p><h2 id="Traefik❎"><a href="#Traefik❎" class="headerlink" title="Traefik❎"></a><a href="https://doc.traefik.io/traefik/https/tls/">Traefik</a>❎</h2><blockquote><p>补充说明：</p><p>虽然提起自动签 HTTPS 证书的 web server，第一个能想到的通常是 Caddy。但是我们正在使用的网关是 Traefik，理由是：</p><ol><li>Traefik 原生自带一个 Kubernetes Ingress Controller，天然支持 k8s</li><li>Traefik-Mesh 可以非常方便地完成 k8s 集群内的 Service Mesh</li><li>从开始调研 k8s 网关的那天到写文章的这一天，Caddy 的 <a href="https://github.com/caddyserver/ingress">Ingress Controller</a> 仍然是 WIP 状态。如果想要在 k8s 集群里使用，要么使用 WIP 版本，要么自己开发 Ingress Controller</li></ol></blockquote><blockquote><p>防时空穿越的补充说明：写文章时，Traefik 版本号为 v2.8.3</p></blockquote><p>恰好 Traefik 有自动签发证书功能。于是乎先调研一下 Traefik 符不符合这个需求。</p><p>Traefik 自动签发证书的设定是这样，启用以后：</p><ol><li>用户写路由规则 (IngressRoute)，Traefik 会读取配置 <code>tls.domain</code> 或者是匹配规则的 <code>Host</code> 部分</li><li>Traefik 根据 IngressRoute 自动尝试签发、续期等</li></ol><hr><p>按照上面的设定，我们要做的应该是：</p><ol><li>用户在 xlog 绑定好域名后，创建一个 IngressRoute</li><li>等等，好像不太对！这个逻辑不就和发给 cert-manager 一样了么？</li></ol><p>那我们换一种：</p><ul><li>我们编写一个 Traefik Middleware，使得某个域名解析完成第一次访问到 Traefik 时，自动创建 IngressRoute 来让它签发证书</li></ul><p>虽然有点别扭，弯弯绕绕有点多，但功能上好像挺完美的；只有一些（或许）可以忍受的小缺点：</p><ol><li>需要编写一个 Middleware，并且运行一个服务<ul><li>逻辑大概是：验证域名有没有绑过 -&gt; 创建 IngressRoute</li><li>如果想用网关安全的自动签发证书，这样的逻辑应该是不可避免的</li></ul></li><li>至少第一次来访问仍然是失败或者非 HTTPS 的</li></ol><h3 id="哪里不对劲？-1"><a href="#哪里不对劲？-1" class="headerlink" title="哪里不对劲？"></a><span style="color:green">哪里不对劲？</span></h3><p>不对劲就在于 Traefik 的自动签证书功能可以看做一个玩具：</p><ul><li>在这个如果没有逐条看都发现不了的<a href="https://doc.traefik.io/traefik/v2.8/providers/kubernetes-crd/#letsencrypt-support-with-the-custom-resource-definition-provider">文档</a>里，说明了 Traefik 2.0 被设定为一个完全无状态的服务，多个 Traefik 之间并不共享什么东西。因此，如果要管理证书，它必须是一个单点（或者你可以花钱买企业版）。<ul><li>这段文字并不在 <code>TLS</code> &#x2F; <code>Let&#39;s Encrypt</code> &#x2F; <code>Kubernetes and Let&#39;s Encrypt</code> 这些标题下面，而是在介绍 IngressRoute 的文档里</li><li>这也是 Traefik 的 ratelimit 相当难算的原因，你必须知道集群里现在运行了几个 Traefik，然后靠概率模拟计算</li></ul></li></ul><p>我们为什么要花钱买一个很别扭的方案？</p><h2 id="Caddy✅️"><a href="#Caddy✅️" class="headerlink" title="Caddy✅️"></a><a href="https://caddyserver.com/docs/automatic-https">Caddy</a>✅️</h2><p>最后，还得是 Caddy。</p><p>它有两种自动签发证书的逻辑：</p><ol><li>第一种是常用的，明确域名的模式：<ol><li>必须先把域名解析完成</li><li>再启动 caddy，配置文件里要写明监听的域名</li><li>启动后，caddy 会立即签好证书，用户来访问直接就是可用的</li></ol></li><li>第二种按需模式：<ol><li>只要启用，来一个域名就签一个</li></ol></li></ol><p>我们需要第二种，它的缺点是：</p><ol><li>第一次访问会比较慢（要签证书）</li><li>有安全风险，很容易成为被攻击的入口<ul><li>因此 caddy 要求，生产环境应该提供一个 <code>ask</code> 配置，询问一个 HTTP 接口，得到应不应该签发的响应</li></ul></li><li>默认情况下，caddy (当前 v2.5.2) 需要给每个实例配置一个 data 的<a href="https://caddyserver.com/docs/conventions#data-directory">持久化</a>目录，也就意味着默认存储配置下它也必须是个单点<ul><li>好在有第三方的存储插件可以让多个 caddy 实例读写同一处存储</li></ul></li></ol><hr><p>为了解决问题 2，我们要写一个简单的 HTTP 服务用来校验域名（是否解析好、是否绑定过等）；为了解决问题 3，我们必须自己编译 caddy：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># caddy-tlsredis 这个插件会把数据放在 redis 里，让多个 caddy 实例共享以达到高可用</span></span><br><span class="line"><span class="comment"># 可以在这里直接用打包好的镜像 https://github.com/sljeff/caddy-tlsredis-docker</span></span><br><span class="line">xcaddy build --with github.com/gamalan/caddy-tlsredis</span><br></pre></td></tr></table></figure><p>然后我们的 Caddyfile 会是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        storage redis &#123;</span><br><span class="line">                # 存储改为 redis，这里可以为空，然后通过环境变量来覆盖配置</span><br><span class="line">                # 详见 https://github.com/gamalan/caddy-tlsredis</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        on_demand_tls &#123;</span><br><span class="line">                # 这里是我们写好的验证服务，可以和每份 caddy 一起部署</span><br><span class="line">                ask http://localhost:5000/</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:80, :443 &#123;</span><br><span class="line">        tls &#123;</span><br><span class="line">                # 自动按需签发</span><br><span class="line">                on_demand</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 这里是实际的上游服务</span><br><span class="line">        reverse_proxy 127.0.0.1:3000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了来一个域名签一个证书；缺点是第一次来会比较慢。</p><h3 id="最后一点小优化"><a href="#最后一点小优化" class="headerlink" title="最后一点小优化"></a><span style="color:green">最后一点小优化</span></h3><p>回顾一下我们的需求，里面有一条：</p><ul><li>用户可以产生自定义的二级域名如 <code>jeff.xlog.app</code></li></ul><p>这就意味着所有用户都会产生一个二级域名；如果我们给每个二级域名都单独签发一个证书，好像浪费有点多。</p><p>更合理的做法是给 *.xlog.app 签发泛域名证书。但是泛域名证书需要 DNS-challenge（证明整个域名的所有权），因此我们要更新 caddy 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要把 xlog.app 的 dns 服务商的插件也加进去编译，以便签发和续期泛域名证书</span></span><br><span class="line">xcaddy build --with github.com/gamalan/caddy-tlsredis --with github.com/caddy-dns/cloudflare</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Caddyfile 中间加这一段匹配，让其余的走到 :80, :443</span><br><span class="line"></span><br><span class="line">xlog.app, *.xlog.app &#123;</span><br><span class="line">        tls &#123;</span><br><span class="line">                dns cloudflare &#123;env.CF_API_TOKEN&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse_proxy 127.0.0.1:3000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最后，大功告成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先解决标题党的问题&quot;&gt;&lt;a href=&quot;#先解决标题党的问题&quot; class=&quot;headerlink&quot; title=&quot;先解决标题党的问题&quot;&gt;&lt;/a&gt;先解决标题党的问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;实际需求和标题有些差异，但很难在一个短标题里描述出完整的需</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>回忆我中学时代的技术</title>
    <link href="https://jeff.wtf/2021/06/secondary-school-days-with-programming/"/>
    <id>https://jeff.wtf/2021/06/secondary-school-days-with-programming/</id>
    <published>2021-06-29T14:16:09.000Z</published>
    <updated>2022-08-18T17:07:21.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实已经记不清楚是 2009 还是 2010 年，但我能找到的最早的记录出现在 2010 年。</p><p>所以我和「电脑技术」的故事应该要从 2010 年说起。</p></blockquote><h1 id="开端：我的第一台「计算机」"><a href="#开端：我的第一台「计算机」" class="headerlink" title="开端：我的第一台「计算机」"></a>开端：我的第一台「计算机」</h1><p>现在的小朋友应该很难想象：2010 年在一个四线城市，如果一个初中生家里没有电脑，那么除了网吧他就几乎没有「连接自由互联网」的办法。</p><p>虽然印象中当时班里电脑普及率也没有特别高，但是有些老师已经在经常布置一些需要查阅资料的作业了。比如「摘抄一些外国名著」、「听贝多芬命运交响曲并写听后感」之类。这样的作业基本都是叫我爸带我去网吧做，但有时候他太忙不能带我去我就会没有办法做。</p><p>于是在我的<strong>多次提议</strong>下，我爸终于去电脑城买了一台笔记本电脑。</p><p>我的第一台「计算机」。</p><p>它是一台非常破旧的二手电脑，牌子是明基。当时明基应该已经不做 PC 了，印象中原生产时间应该在 2006 年左右；它的 CPU 是 AMD 的一个单核处理器，当时查阅的资料没错的话貌似还是第一块消费级量产的 64 位处理器；板载的 ATI 显卡，当然，ATI 当时也已经不存在了；内存应该是 DDR2 的 1GB 内存；操作系统是 Windows XP。</p><p>当年的网络可以选择铁通、网通、电信，流传一句话是「南电信，北网通」；而且流传说铁通用是电信和网通的内网；当然，还是果断选择了最便宜的 2Mbps 铁通。看起来应该是扁的两股的电话线接入，用猫（调制解调器）转成网线信号，由电脑来拨号上网。当时可没有用路由器这种东西。</p><h1 id="属于「黑客」的年代"><a href="#属于「黑客」的年代" class="headerlink" title="属于「黑客」的年代"></a>属于「黑客」的年代</h1><p>我也不知道为什么，明明在小学经常去游戏厅和网吧甚至被我爸和班主任都亲手抓到过；身处在网游时代拥有了一台电脑以后，却没有爱上网络游戏。可能因为它性能太烂了。</p><blockquote><p>这一年唯一用这台电脑认真玩过的「大型」游戏是 00 年代初的《秘密潜入》（IGI），一款潜入类型的单机游戏，一共有十四关；我照着攻略能打到第七关。</p></blockquote><p>没有被游戏占满时间，所以我的时间线从这里开始分叉。这一年吸引我的是两个东西：</p><ol><li>因为它性能太烂，我必须找各种方式优化它</li><li>在寻找优化方法的时候偶然看见了当年的 hackbase 黑基网，疯狂想要成为一个「黑客」</li></ol><h2 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h2><p>优化无非是：重装系统；使用各种优化工具。</p><p>和每个学生时代刚刚学会重装系统的人一样，我在学会这个技能以后就开始频繁给电脑重装系统。而且喜欢找各种各样的系统。</p><p>当时的带宽太小，如果想装游戏或者装系统，最快的办法就是去电脑城买碟。不论什么碟，统统四块钱一张。当然都是盗版。</p><p>我买了大量的碟，包括：Windows 2000、Windows Vista、Windows 7，以及各种各样写着「优化精简」的雨林木风、番茄花园、深度的 Windows XP，还有写着「网页三剑客」但实际上并不能安装的工具类碟。还经常发生类似「Vista 发音不对导致电脑城老板听不懂」之类的轶事，不一而足。</p><p>那个时候认识的朋友都知道，只要电脑出问题了找我，我就会提着一塑料袋光盘来到他家门口，把问题全部解决。也有失败的时候，后来我遇到一个电脑没装光驱的人。</p><hr><p>我第一次用桌面版 linux 也是在这段时间，用的是雨林木风 OS（后来改名叫 StartOS）。原因是我初中住校，某次周末回家发现桌面上都是我爸上网中了木马以后导致的删不掉的图标，一气之下装了一个不能运行 exe 所以绝不会中木马的系统。</p><hr><p>优化工具方面其实用了很多，但是最重要的就是 360 全家桶。当年是 360 刚刚大火的时间点，装好 360 全家桶是「电脑达人」的证明。</p><p>2010 年以及后面几年发生的事情同时代人应该都经历过：「3Q 大战」、「360 把浏览器伪装成系统补丁」、「360 浏览器把默认搜索引擎换成自家搜索，一夜之间成为国内第二大搜索引擎」。</p><p>两件事，有点讽刺：</p><ul><li>当年的 3Q 大战，舆论一边倒支持 360，腾讯被群嘲；不过没过几年，很快 360 就成为了流氓的代名词</li><li>等后面几年出现了百度杀毒等等竞品，会发现如此流氓的 360 全家桶的流氓程度也远不及它们</li></ul><p>也不知道互联网的世道是变好了还是变坏了。</p><h2 id="「黑客」篇"><a href="#「黑客」篇" class="headerlink" title="「黑客」篇"></a>「黑客」篇</h2><p>当年的黑基网和现在完全不一样，我记得首页全是各种「电脑技巧」、「黑客教学」的标题，点开就是一些下载链接。特别强调：不像现在的下载站的各种云盘外链或者假链接，那里的下载链接就是那个网站的真实的下载链接。</p><p>下载下来的东西会是一个压缩包，解压密码通常是网站的网址。解压出来的东西基本都是一个 <code>.exe</code> 和一个 <code>.txt</code>：<code>.exe</code> 是屏幕录像专家录制的视频（可能是为了在没有播放器的电脑上也能播放）；<code>.txt</code> 则是教学内容，当年的黑客教程很少有开口说话的，所以会在记事本里打字和看视频的人交流，最后也会留下这个 txt 一起发出来。</p><p>当然，这样的「黑客」网站也不止黑基网一个，还有各种各样的「黑客基地」、「黑客论坛」。需要在今天特别强调的是：这些网站和论坛真的很有用。</p><p>在没有严格备案的混沌互联网时代，国内有很多现在已经没有的网站。</p><hr><p>用今天的眼光看，在好奇心驱使下的我做的所谓「黑客」的事情有这样四种：</p><h3 id="零、编程和录制黑客教程"><a href="#零、编程和录制黑客教程" class="headerlink" title="零、编程和录制黑客教程"></a>零、编程和录制黑客教程</h3><p>俗话说互联网是有记忆的。</p><p>2019 年我在网上找到了我初中时代录制的一个「黑客教程」。解压出来以后两个文件的时间戳是 <code>2010/8/6</code>；2020 年 11 月找到一个转制工具把屏幕录像专家的 <code>.exe</code> 视频转成了 mp4：</p><p><img src="/2021/06/secondary-school-days-with-programming/hack-tutorials.jpg"></p><p>打开看还是非常羞耻的。但我还是鼓起勇气看了几眼，里面的内容大概是：</p><p><img src="/2021/06/secondary-school-days-with-programming/hack-tutorial-1.jpg"></p><blockquote><p>硕大的「黑&#x2F;客&#x2F;平&#x2F;民&#x2F;化」</p></blockquote><p><img src="/2021/06/secondary-school-days-with-programming/hack-tutorial-2.jpg"></p><h3 id="一、可能可以叫「二进制安全」"><a href="#一、可能可以叫「二进制安全」" class="headerlink" title="一、可能可以叫「二进制安全」"></a>一、可能可以叫「二进制安全」</h3><p>灰鸽子可能听说过的人就比较多了。他其原理就是一个远程控制软件，只要把客户端生成好、分发给别人安装，然后自己的电脑有一个固定的公网地址作为服务器，就可以远程控制别人的电脑了。</p><p>听起来不就是一个普通的远程控制软件么？其实不然，杀毒软件们之所以把灰鸽子的客户端标识为木马，主要是因为它的客户端是做成：无感运行、默认开机启动、防止自己被杀死的。</p><p>对于我来说，玩转这一套有两个需要解决的问题：</p><ol><li>铁通没有公网地址而且每次拨号没有固定 IP，怎么配服务器地址去生成客户端呢？</li><li>如何防止灰鸽子客户端被杀毒软件杀死？</li></ol><p>我当时是一个没有网络知识的初中生，如何解决问题 1 只是模糊搜到一些名为「内网穿透」、「DDNS」之类的解法，并不知道其中的含义。最终使用的是向日葵的一个软件，现在想想原理应该类似 frp：在我本地启动一个向日葵软件，向日葵给我一个域名和端口，通过它可以连到我的电脑的某个端口。更离谱的是这个域名不随机，甚至还能自定义（子域名）。这样服务器地址的问题就解决了。</p><p>问题二的专业名词大概叫「免杀」吧，当时知道的解法主要是：</p><ul><li>用 16 进制编辑器改汇编，把杀毒软件识别到的特征码改掉（照着别人的教程操作）。然后和另一个普通的 .exe 绑在一起，最后把图标改掉发布出去。</li><li>套壳。我也不懂什么是套壳，大概是把他的入口改掉、以及那些汇编特征码不会被识别到</li></ul><p>我也用了一种特别的办法来发布这个二进制：因为当时易语言相关的东西经常被 360 误杀（实际上是太多人用易语言写病毒，360 识别的特征在很多易语言编译出来的普通软件也包含），所以我在百度空间写了一篇文章教学易语言；这个文章有一些关键词的 SEO 做的比较好，会排在前几；文章里面需要读者先下载我的工具，并且要求他们忽略 360 的提示。</p><hr><p>我用这样的方法确实成功控制到了一些人的电脑，但并没有做任何「打开摄像头」之类变态的事情。最过分的一件事可能是往别人的电脑上传了一个 txt 文件，然后传统艺能，在他浏览桌面时弹开这个文件用记事本和他文字对话。</p><h3 id="二、web-安全"><a href="#二、web-安全" class="headerlink" title="二、web 安全"></a>二、web 安全</h3><p>那个时代有重大漏洞的 CMS 太多了，而且大家都用 asp 或者 php 的 CMS 做网站，所以根本不需要用到 CSRF &#x2F; XSS 这样稍微高阶的技巧。用一些步骤就可以很容易做到：</p><ol><li>下载啊 D 注入工具</li><li>当年 Google 还能用，打开 Google，把搜索设置改成一页显示 100 条</li><li>用 Google 搜索 <code>inurl:asp?id=</code></li><li>啊 D 注入工具就会开始扫这个页面里的所有链接能不能被 SQL 注入</li><li>发现看起来像可以被注入的页面就去扫它的后台地址，以及尝试 SQL 注入取到 admin 或者 user 表</li><li>扫到后台地址以后，用表里的账号密码，不行就用弱口令</li><li>如果表里的密码有 md5，就去找彩虹表</li></ol><p><img src="/2021/06/secondary-school-days-with-programming/a-d.jpg"></p><blockquote><p>这个图片是我在 2014 年想做黑客教学网站的时候重新下载并截图的……</p></blockquote><p>由于当时大家都用差不多的 CMS 做网站，即使你想针对一个网站这样做，成功率也非常高。</p><p>更有甚者只需要两步：扫后台地址；弱口令或者 <code>&#39; or 1=1</code> 进后台。比如我的初中母校官网。</p><hr><p>当时我的初中同校还有另一个人也经常做这样的事情，他知道我，我也知道他。</p><p>初中学校官网就是我们两个一起「解决」的。他找到了后台地址，并且弱口令进了后台，但是不知道后面该怎么操作；我找到一个可以上传文件的地方，把某个「一句话菜刀」上传进去了。</p><p>我们只是在 QQ 上交流，但交际圈很小，我很容易就知道他的真实身份；有一次我在现实里偶遇他，也没有对他说任何话，低头匆匆走掉了。</p><h3 id="三、社会工程学"><a href="#三、社会工程学" class="headerlink" title="三、社会工程学"></a>三、社会工程学</h3><p>当年流行「刷钻」。</p><p>手机端的刷钻原理是找运营商和腾讯的时间差，用某个固定发短信步骤去开通 QQ 的钻，就有概率可以实现运营商不扣钱但是腾讯认为你开了钻。我的超级 QQ 和黄钻一直坚持到我上高中换手机号前都没有扣钱，并且当时腾讯的页面还显示到期时间是 1971 年。</p><p>PC 端的刷钻软件原理我就不知道了，保守估计 99% 都是钓鱼软件。</p><p>我也用易语言做了一个。本来是给别人做的，只是代码里顺便也发到了我自己的邮箱。</p><h1 id="大建站时代"><a href="#大建站时代" class="headerlink" title="大建站时代"></a>大建站时代</h1><h2 id="免费空间、免费域名"><a href="#免费空间、免费域名" class="headerlink" title="免费空间、免费域名"></a>免费空间、免费域名</h2><p>一切的一切要从初中信息课本说起，上面有一篇如何建一个网站。里面的步骤是在一个叫做 5944 的网站注册账号，他会送你一个能运行 php 的免费空间、一个免费数据库和一个免费二级域名，然后上传一个 CMS 上去。</p><p>早期 5944 这个网站甚至没有广告，只是经常访问不出来；后来它会在我的 HTML 页面内容里面插广告（就像后来运营商在网页里做的那样）。当然，既然是插入一段广告代码，必然也是有办法写 js 给他屏蔽掉的。</p><p>当时的免费空间除了 5944 还有 <code>freewebhosting</code>、<code>com.nu</code> 等等等等。还有各种免费资源的收集站，比如免费吧 free8、奇哈免费网等等。后来免费资源的收集站都陆续倒闭了，免费空间倒是有很多留存至今。</p><p><img src="/2021/06/secondary-school-days-with-programming/2012-qiha.jpg"></p><blockquote><p>至少邮件还能看见，勉强能感受一下当时的氛围</p></blockquote><p>免费域名则大多都是二级域名 <code>co.cc</code> 以及上面的 <code>com.nu</code> 等等，当然不能不提可能是唯一的免费顶级域名 <code>.tk</code>。</p><p>由于使用 <code>.tk</code> 建无意义站的人太多，百度甚至会给这个域名后缀的网站降权。</p><h2 id="域名贩子"><a href="#域名贩子" class="headerlink" title="域名贩子"></a>域名贩子</h2><p>我还记得我成为域名贩子的契机：打开了爱名网 <code>22.cn</code>，发现很多便宜的 <code>.cn</code> 域名。</p><blockquote><p>当年的域名市场经过一个大的起伏，主要是 <code>.cn</code> 一度降到白菜价，后来又被禁止个人身份使用（不允许 IDC 商做绑定）。当然，那个年代嘛，一样有办法绕过。</p></blockquote><p>那一年我拿了我所有的几百块压岁钱，全部在电话亭换成了手机充值卡。然后在网上买了一个成年人的支付宝账号，用话费卡充值（没错，当年可以用话费卡给支付宝充值），再去爱名网交易。</p><p>当时买完了域名为了卖出去，我还写了一些软文投到站长之家，来推广自己卖域名的网站。由于很多爬虫和人类不看内容就在那乱爬或者乱引用，所以现在依然能够搜到这样两篇 2011 年的：</p><p><img src="/2021/06/secondary-school-days-with-programming/2011-article.jpg"></p><p><img src="/2021/06/secondary-school-days-with-programming/2011-article-2.jpg"></p><blockquote><p>如果今天你看到有文章写的一塌糊涂，注意：他有可能是一个机器人，也有可能是一个初中生。</p></blockquote><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>除了上面截图想要推广的两个网站以外，初中时代还用免费空间做过各种没有意义的网站。</p><p>当年比较火的 CMS 有织梦 CMS、帝国 CMS。织梦有一个功能，是可以直接在后台配置一个规则然后把别人整个网站的文章抓过来。</p><blockquote><p>所以可以理解为什么上面两篇废物文章能在搜索引擎里出现好几次了。</p></blockquote><p>我还用帝国 CMS 做过一个非常非常小众的（合理怀疑现在生活范围内的人里面不会有第二个人知道名字的）网络歌手的粉丝站，高峰时居然一些文章还有几十的评论。</p><p>其余就是去脚本之家找各种各样的 CMS 来用，并没有什么实际意义。</p><p>这段时间留下来的东西还有一些<strong>尬到脚趾抠地</strong>的帖子：</p><p><img src="/2021/06/secondary-school-days-with-programming/2011-hu60-1.jpg"><img src="/2021/06/secondary-school-days-with-programming/2011-hu60-2.jpg"><img src="/2021/06/secondary-school-days-with-programming/2011-hu60-3.jpg"><img src="/2021/06/secondary-school-days-with-programming/2011-hu60-4.jpg"></p><h2 id="广告联盟"><a href="#广告联盟" class="headerlink" title="广告联盟"></a>广告联盟</h2><p>广告联盟可能是做一名普通站长当时唯一的收入来源。</p><p>我也建了一个网站，附上广告联盟的广告，然后使用了：互点平台。</p><p>我帮别人点广告，别人也帮我点广告。这个互点平台还可以配置网页上一个页面（跳转的来源），一般会配置成搜索引擎，这样让广告联盟来检查整个追踪链路不会发现端倪。</p><p>但一个新的网站没有什么关键词搜索会有看起来合理的流量进来，强行写一个搜索结果页面作为来源也很容易辨别。于是我想到了那个百度空间的易语言教程。我把来源配置成那个页面，在那个页面附上新网站的链接，最后开始互点。</p><p>最终广告联盟找到我结余了一天的钱（印象中二十几块）并说广告商不满意，终止合作。</p><h2 id="网页制作大赛"><a href="#网页制作大赛" class="headerlink" title="网页制作大赛"></a>网页制作大赛</h2><p>网页制作大赛是一个中考加分项。我在初三买了一本 Dreamweaver 网页制作的书，班主任通知这个加分项的时候我的桌上正好摆着这本书。班主任过来告诉我你可能拿个不错的奖项。</p><p>直到我报名以后才发现很多同班同学也报名了，大多是教师子弟；而他们的「作品」是周末花钱去找一些成年人帮忙做的。</p><p>我在我提交的网页的 <code>&lt;meta&gt;</code> 里写了很多类似「我无所谓」的话。理所应当最后我什么奖也没有拿到。</p><h1 id="我的编程"><a href="#我的编程" class="headerlink" title="我的编程"></a>我的编程</h1><p>中学时期主要靠好奇心的本能学习，代码量实际并不多。</p><p>初中阶段除了易语言和建站写的一点点 HTML 以外，印象深刻的事有两件：</p><ol><li>初中的中午午睡时会偷偷在被子里看 VB 教程。</li><li>会给 MRP 平台（国产山寨机）的软件解包，替换资源文件再打包；比如把麻将 app 的语音换成自己的</li></ol><p>高中看过 Java 编程思想和 C51 单片机编程：</p><p><img src="/2021/06/secondary-school-days-with-programming/2014-01-14-tieba.jpg"></p><p><img src="/2021/06/secondary-school-days-with-programming/2014-01-14-java.jpg"></p><blockquote><p>上面贴吧和 Java 编程思想照片都是 2014 年 1 月的图</p></blockquote><p>而且由于高中打通了多部仙剑古剑，在高三时非常想成为一个游戏开发者，也试着用 RPG Maker （当时还是 ruby 做为它的脚本语言）写了一些东西：</p><p><img src="/2021/06/secondary-school-days-with-programming/2014-03-game.jpg"></p><blockquote><p>手写 ruby 瞩目</p></blockquote><p><img src="/2021/06/secondary-school-days-with-programming/2014-04-paper.jpg"></p><blockquote><p>2014 年 4 月的照片。当时会关注游戏引擎（2014 能算最后的靠报纸看新闻的年代吧），并且十分想进上海烛龙。</p></blockquote><hr><p>2014 年，我的中学结束了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;其实已经记不清楚是 2009 还是 2010 年，但我能找到的最早的记录出现在 2010 年。&lt;/p&gt;
&lt;p&gt;所以我和「电脑技术」的故事应该要从 2010 年说起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;开端：我的第一台「计算机」&quot;&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>HDMI 转 DP 方案之毕亚兹 ZH110 使用评测</title>
    <link href="https://jeff.wtf/2021/06/HDMI-DP-ZH110/"/>
    <id>https://jeff.wtf/2021/06/HDMI-DP-ZH110/</id>
    <published>2021-06-08T06:38:00.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TLDR：如果要带 4k60hz，别买；其他情况都还行</p></blockquote><hr><p>前置知识：</p><ul><li>「DP的带宽比HDMI高，从DP转HDMI是从高到低，被动芯片就能完成，所以便宜而常见；反之就相反，需要主动芯片，就贵且罕见」</li><li><a href="https://www.zhihu.com/question/27331119">https://www.zhihu.com/question/27331119</a></li><li>毕亚兹 ZH110 支持 4k60hz ，需要外直供电，询问客服确认可以 HDMI 2.0 转 DP 1.2 跑满 4k60hz</li></ul><hr><p>为什么要买 HDMI 转 DP 的线：</p><ul><li>有一个 4k 显示器，只有一个 HDMI 口一个 DP 口；有两个游戏机一个笔记本都只有 HDMI 输出</li><li>买了个不带主动供电的 HDMI 切换器，声称线材总长不超过 2m 时支持 4k60hz，但是实际使用时会闪断、黑屏</li></ul><hr><p>实际体验：</p><ul><li>比较热，没有温度计，手摸，大胆预测 50 到 60 摄氏度</li><li>没有闪断黑屏，但是在 4k60hz 模式下，只要 PC 暂停声音二十秒左右，就无法再通过 HDMI 口输出声音，需要重新插拔才可以</li><li>如果不用 4k60hz，让两个游戏机走 DP 到显示器的话：只要把 HDMI 转 DP 线接在 HDMI 切换器后面，屏幕就会不停地被唤醒</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;TLDR：如果要带 4k60hz，别买；其他情况都还行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;前置知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「DP的带宽比HDMI高，从DP转HDMI是从高到低，被动芯片就能完成，所以便宜而常见；反之就相反，需</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>如何使用vscode远程debug项目</title>
    <link href="https://jeff.wtf/2020/06/vscode-remote-debug/"/>
    <id>https://jeff.wtf/2020/06/vscode-remote-debug/</id>
    <published>2020-06-14T11:03:45.000Z</published>
    <updated>2022-08-16T14:08:06.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-06-14-记录"><a href="#2020-06-14-记录" class="headerlink" title="2020.06.14 记录"></a>2020.06.14 记录</h2><p>vscode 的 golang 插件最近开始由 golang 官方维护，插件的 debug 功能（尤其是remote debug）还<a href="https://github.com/golang/vscode-go/blob/master/docs/debugging.md#troubleshooting">处于不完善的阶段</a>，配置文件最近有过几次改动。不能用的话要多参考下官方文档：</p><p><a href="https://github.com/golang/vscode-go/blob/master/docs/debugging.md">https://github.com/golang/vscode-go/blob/master/docs/debugging.md</a></p><p>下面是目前的最佳实践配置和一些文档相关的解释。</p><h2 id="远端启动"><a href="#远端启动" class="headerlink" title="远端启动"></a>远端启动</h2><blockquote><p>这一节是根据我公司内部的项目结构和生产环境配置来的，领会精神即可。重点是下面的<strong>本地配置</strong>章节。</p></blockquote><p>项目的 <code>docker/debug.dockerfile</code> 里面要这样配置 entrypoint：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/dlv&quot;, &quot;--log&quot;, &quot;--accept-multiclient&quot;, &quot;-l=:40000&quot;, &quot;--headless=true&quot;, &quot;--api-version=2&quot;, &quot;exec&quot;, &quot;/app&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p><code>--accept-multiclient</code> 可以让客户端 dlv 多次连接和断开</p><p><code>--api-version=2</code> 是一定要配置的，否则默认是 1</p><p>PS: <code>--continue</code> 参数需要测试，可以让 dlv 启动的时候就运行 <code>/app</code>，目前需要连接一次才会启动</p></blockquote><p>k8s deploy.yml 里需要接的 <code>/app</code> 的参数则是（grpc staging 为例）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">grpcsvc</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--env</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">staging</span></span><br></pre></td></tr></table></figure><p>另外建议 deploy 里把 health check 去掉，内存至少给个 200m。</p><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><h3 id="1-vscode-的-luanch-json"><a href="#1-vscode-的-luanch-json" class="headerlink" title="1. vscode 的 luanch.json"></a>1. vscode 的 luanch.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Connect to server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;go&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;remote&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;remotePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/builds/infra/service/learning&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">40000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>详细解释在最下方。</p><h3 id="2-映射-pod-端口到本地"><a href="#2-映射-pod-端口到本地" class="headerlink" title="2. 映射 pod 端口到本地"></a>2. 映射 pod 端口到本地</h3><ol><li>应用端口，比如 grpc 为启动时监听的 6000 端口</li><li>dlv 启动时监听的端口 40000</li></ol><p>pod 会有 log 显示 dlv 连接、创建断点等等行为</p><h3 id="3-把-go-mod-的下载目录软链接到仓库目录"><a href="#3-把-go-mod-的下载目录软链接到仓库目录" class="headerlink" title="3. 把 go mod 的下载目录软链接到仓库目录"></a>3. 把 go mod 的下载目录软链接到仓库目录</h3><p>比如我本地默认的 GOPATH 是 <code>~/go</code>，默认 go mod 的下载目录是 <code>~/go/pkg/mod</code>，那么在仓库根目录（比如 <code>~/proj/learning</code>）操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p .cache/pkg</span><br><span class="line"><span class="built_in">ln</span> -s ~/go/pkg/mod/ .cache/pkg/mod</span><br></pre></td></tr></table></figure><p>这些完成后就可以用 vscode 打断点调试了。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="remotePath"><a href="#remotePath" class="headerlink" title="remotePath"></a>remotePath</h4><p>这个参数实际上指的是远端运行的二进制在<a href="https://stackoverflow.com/questions/59652312">编译时的路径</a>。</p><p>比如名为 <code>learning</code> 的项目在我们的 gitlab runner 上编译时，当时路径为 <code>/builds/infra/service/learning</code>。</p><blockquote><p>这个路径可以在本机 <code>dlv connect 127.0.0.1:40000</code> 后，用 <code>sources</code> 命令查看所有包找到（会列出全部的包，需要搜索一下找到）。</p></blockquote><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><p>vscode 会根据 <code>remotePath</code> 参数和<strong>本地的仓库目录</strong>来<a href="https://github.com/golang/vscode-go/issues/45">计算根目录</a>，映射时去掉不重复的前缀。</p><blockquote><p>2020.06.14 经测试 goland 会很智能的映射文件，但有时还是会出错，比如遇到我们 replace 过的库。</p><p>vscode 经过正确映射可以不出错，官方也在尝试加入<a href="https://github.com/golang/vscode-go/issues/45">自动映射文件</a>。</p></blockquote><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>上面这样配置之后，可以正确映射出项目仓库里的文件，我们可以跳转和打断点到正确的行数。</p><p><strong>但是这时 go mod 下载目录里的第三方库的代码是没办法调试的。</strong></p><p>这是因为 build 出的二进制会记录代码的位置和行数。比如用到 <code>github.com/shanbay/ent@v0.0.0-20191225103539-6a58606d250c</code> 这个库：</p><ul><li>在我本地的位置是 <code>~/go/pkg/mod/github.com/shanbay/ent@v0.0.0-20191225103539-6a58606d250c/</code></li><li>gitlab runner 上 build 镜像时，为了缓存第三方库，所以我们把 GOPATH 配置成了相对路径 <code>.cache</code>。所以二进制记录的位置是 <code>/builds/infra/service/learning/.cache/pkg/mod/github.com/shanbay/ent@v0.0.0-20191225103539-6a58606d250c/</code></li></ul><p>在调试的时候 step in 或者打断点，都会没办法映射到本地的文件。vscode 暂时也没有提供一个参数映射 go mod 位置（但是<a href="https://github.com/golang/vscode-go/issues/45">有人提过</a>了）。</p><p>所以我们这里给了一个软链接，软链接之后 <code>learning/.cache/pkg/mod/github.com/shanbay/ent@v0.0.0-20191225103539-6a58606d250c/</code> 目录在本地也存在，所以就能够正常调试了。</p><p>标准库同理，我在本地的标准库默认位置是 <code>/usr/local/go/src</code>，gitlab runner 上 build 时标准库也在这个目录，所以不用软连接也可以正确调试和打断点。</p><blockquote><p>所以远端调试，最方便的方法是在远端运行本地 build 出来的 debug 二进制，这样映射关系不用配置就是正确的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2020-06-14-记录&quot;&gt;&lt;a href=&quot;#2020-06-14-记录&quot; class=&quot;headerlink&quot; title=&quot;2020.06.14 记录&quot;&gt;&lt;/a&gt;2020.06.14 记录&lt;/h2&gt;&lt;p&gt;vscode 的 golang 插件最近开始由 go</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>用go重写项目之后，我们这样做回归测试</title>
    <link href="https://jeff.wtf/2020/04/regression-testing/"/>
    <id>https://jeff.wtf/2020/04/regression-testing/</id>
    <published>2020-04-12T06:26:24.000Z</published>
    <updated>2022-08-19T00:48:13.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讲讲效果"><a href="#讲讲效果" class="headerlink" title="讲讲效果"></a>讲讲效果</h2><p>先讲讲从python-&gt;go重写项目的最终结论：在高峰期统计总资源使用量，算出重写后的go版相比重写前的python版CPU使用下降了74%，内存使用下降了94%。</p><p>不过重写一个项目，在写代码这件事本身结束以后，从检查新代码正确性一直到最后上线还有一段漫长的过程。本文就记录了我们这一段过程的实践。</p><h2 id="术语和业务的背景"><a href="#术语和业务的背景" class="headerlink" title="术语和业务的背景"></a>术语和业务的背景</h2><p>先介绍背景。我们有一个流量较大的grpc服务，本文暂且给它取代号叫做abc。用python和go实现的版本我们把它叫做abc-py和abc-go。</p><ul><li>abc原本是一个python编写的grpc项目，主要使用了我们的grpc框架<a href="https://github.com/shanbay/sea">sea</a></li><li>abc实现了数个grpc的servicer，每个servicer都可以对应HTTP&#x2F;2的一个path。这次我们重写实现了其中一个grpc servicer，对应的path我们把它叫做<code>/abc.Abc/</code>；没有用go重写的部分的path都统一起来叫做<code>/abc.XXX/</code></li><li>k8s集群里其他应用请求grpc服务时，都要经envoy做HTTP&#x2F;2的反向代理</li></ul><p>结构图简化如下：</p><p><img src="/2020/04/regression-testing/abc-before.png"></p><h2 id="测试的背景"><a href="#测试的背景" class="headerlink" title="测试的背景"></a>测试的背景</h2><h3 id="单元测试❎"><a href="#单元测试❎" class="headerlink" title="单元测试❎"></a>单元测试❎</h3><p>我们对比着python代码用go重写了项目以后，会照着新代码以及我们理解的业务逻辑来写新的单元测试。</p><p>但仅仅使用单元测试是不够的，因为：</p><ul><li>单元测试能覆盖的场景有限</li><li>单元测试本质上是白盒测试，重写的单元测试代码和重写的业务代码有一样的问题：<ul><li>会受到已经写过的代码的影响</li><li>会受到逻辑理解的影响</li></ul></li></ul><p>单元测试没有问题的情况下我们也不能放心让代码上线。</p><h3 id="使用abc-py的单元测试代码来测试abc-go❎"><a href="#使用abc-py的单元测试代码来测试abc-go❎" class="headerlink" title="使用abc-py的单元测试代码来测试abc-go❎"></a>使用abc-py的单元测试代码来测试abc-go❎</h3><p>理想情况下，如果能直接使用旧代码的单元测试来测新代码，就不会受到新代码和我们理解错误的影响。</p><p>但单元测试本身就受到代码的影响，比如python的单元测试里我们使用了框架自带的测试组件、要给对象进行mock等；写go的单元测试前我们就要考虑代码的可测试性，测试这件事对代码本身就是有侵入的。</p><p>如果要对原来的单元测试代码进行大量修改，也就必然改动逻辑了。这个方案并不可行。</p><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>不知道定义上是否准确，但根据维基的解释，重写代码并且保证正确性的这种场景我们需要的是「回归测试」。</p><h4 id="黑盒测试❎"><a href="#黑盒测试❎" class="headerlink" title="黑盒测试❎"></a>黑盒测试❎</h4><p>首先我们考虑的是一种和单元测试类似的编写方法：同样覆盖所有功能，但以黑盒测试的角度编写代码。然后使用这个黑盒测试代码测试处在同样环境下的abc-py和abc-go的两个服务，不论我们理解的逻辑如何，只要两边结果完全相同，就可以认为验证成功。</p><p>但：</p><ul><li>相比复杂的用户场景，这个方案能覆盖的场景非常有限</li><li>这样的回归测试方案不能重复使用，我们以后还要迁移很多python项目到go，都要编写只用一次的黑盒测试代码</li></ul><p>于是写黑盒测试代码这种方案也不适合我们。</p><h4 id="镜像流量✅️"><a href="#镜像流量✅️" class="headerlink" title="镜像流量✅️"></a>镜像流量✅️</h4><p>最终我们考虑使用这样的方案：</p><ul><li>首先代码的单元测试是用于验证逻辑错误</li><li>其次功能自测和QA的测试能验证功能是否正确</li><li>最后直接在生产环境部署abc-go服务但并不给用户直接访问，而是把abc-py的流量完全复制一份到abc-go，一段时间后检查每个请求发到abc-py和abc-go得到的响应是否完全一致</li></ul><p>其中最重要的是第三步复制流量的方案。</p><h2 id="复制流量方案"><a href="#复制流量方案" class="headerlink" title="复制流量方案"></a>复制流量方案</h2><h3 id="envoy-diffy❎"><a href="#envoy-diffy❎" class="headerlink" title="envoy + diffy❎"></a>envoy + diffy❎</h3><p>由于我们的流量都经过了envoy，使用它的request_mirror_policy可以很容易的镜像每一个请求。</p><p>而要分析大量的请求和响应，我们找到了<a href="https://github.com/opendiffy/diffy">diffy</a>这个工具。它一开始由twitter维护、目前由opendiffy这个GitHub组织维护。</p><p>他的功能是可以把一个HTTP请求发往两个地方，并且比较和统计他们的输出；在对比结果里也可以方便的选择忽略一部分请求、忽略某个字段、忽略一定百分比内的内容不一致等等，还是比较强大。</p><p>然而它并不支持解析对比grpc的流量，所以我们只能修改了一个提供http接口、功能和abc-py相同的项目（这里把它叫做abc-api），把他自己的逻辑去掉，改为调用abc-go的grpc接口。然后做了镜像流量，最终结构如下：</p><p><img src="/2020/04/regression-testing/mirror-api.png"></p><p>看到结构图以后可以发现，这样的方案明显非常不合理，而我们仅仅是为了用上diffy这个现成的工具就引入了更复杂更不可控的环节：</p><ul><li>我们又修改了一个项目的代码逻辑（abc-api）</li><li>envoy复制了一份流量之后diffy又会复制一份，现在abc-api项目的流量*3</li><li>我们仅仅因为abc-api和abc-py功能类似就认为两者逻辑等效，实际上并非如此，我们应该只对比abc-py和abc-go</li><li>由于有非幂等的请求，我们必须让三份流量的非幂等逻辑各自独立。主要就是写数据库的部分，abc-api&#x2F;复制的abc-api&#x2F;调用abc-go的abc-api三者各自连接了独立的数据库。并且在上线前我们要保证三者完全同步，然后在上线diffy的同时关掉同步。</li></ul><p>于是乎结果就是diffy看到了大量的不一致，但我们无法直接判断不一致是abc-go的问题还是我们修改abc-api引入的新问题。这个方案不可行。</p><h3 id="envoy-对比grpc响应✅️"><a href="#envoy-对比grpc响应✅️" class="headerlink" title="envoy + 对比grpc响应✅️"></a>envoy + 对比grpc响应✅️</h3><p>吸取了上面的经验之后，我们明白请求过程的结构越简单、代码改动越少越好。而对比响应内容带来的复杂性应该被放到这个结构以外，甚至可以离线来做。最终，我们选择使用envoy镜像grpc流量：</p><p><img src="/2020/04/regression-testing/mirror-rpc.png"></p><ul><li>我们配置了envoy的路由，当path为&#x2F;abc.Abc&#x2F;时，请求照旧发到abc-py，但是会镜像一份流量到新部署的abc-go服务</li><li>abc-py和abc-go连接着各自独立的数据库，在镜像流量前两个数据库保持同步</li><li>我们编写了python和go版本的middleware，用来给输入输入以及req_id等数据进行打点。打点数据将会被收集到我们的elasticsearch</li></ul><p>这个方案在结构上，相比一开始只多出一份abc-go的服务；在代码上，相比一开始只多了一个打点的middleware。</p><p>对比响应的方式则是我们定时从elasticsearch拉数据，编写了一个脚本用来对比数据中同一个req_id的两次请求结果是否一致。这个脚本用到了<a href="https://github.com/inveniosoftware/dictdiffer">dictdiffer</a>这个库，功能只是对比响应内容是否一致以及忽略字段等，和业逻辑无关，所以其他业务做回归测试时一样可以使用。</p><p>这样「镜像流量-&gt;对比结果-&gt;修复代码」过程反复多次以后，我们最终能做到一段时间内每个请求abc-py和abc-go都有完全一样的响应。</p><h2 id="灰度上线"><a href="#灰度上线" class="headerlink" title="灰度上线"></a>灰度上线</h2><p>上面的步骤都做完，做到abc-go和abc-py响应完全一致以后，我们还是不能直接替换。为了避免没有想到的情况发生，我们必须灰度上线。</p><p>不过这次灰度上线比以往复杂一些，并不能直接用abc-go一个一个替换abc-py。为了解释更清楚，需要先介绍下之前的envoy配置的路由方案，大致可以简化为（实际上envoy并不像下图一样直接调用k8s的service）：</p><p><img src="/2020/04/regression-testing/envoy-before.png"></p><ul><li>请求进来时，如果请求头的authority为abc-rpc，根据我们的配置，envoy会取到k8s里名为abc-py的这个service对应的pod ip，随机发往其中一个。</li></ul><p>而我们的abc-go只实现了所有authority为abc-rpc的请求里path为<code>/abc.Abc/</code>的这一部分，如果直接用abc-go替换abc-py会有一些请求未实现。</p><p>因此我们的灰度要分为两个步骤来做：</p><ul><li>一：创建新的svc，让<code>/abc.Abc/</code>的请求走到这个新的svc。新svc对应的pod依然是abc-py</li><li>二：一个一个替换掉它们为abc-go</li></ul><p><img src="/2020/04/regression-testing/envoy-after.png"></p><p>上图就是步骤一完成之后的效果。此时所有的请求都没有受到影响，因为并没有abc-go的代码上线。这时我们只要一个一个替换掉abc-py-1&#x2F;2&#x2F;3为abc-go的代码，就能实现灰度上线。</p><p><img src="/2020/04/regression-testing/envoy-after-2.png"></p><p>最终新svc背后的pod都替换成abc-go的代码，项目上线成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;讲讲效果&quot;&gt;&lt;a href=&quot;#讲讲效果&quot; class=&quot;headerlink&quot; title=&quot;讲讲效果&quot;&gt;&lt;/a&gt;讲讲效果&lt;/h2&gt;&lt;p&gt;先讲讲从python-&amp;gt;go重写项目的最终结论：在高峰期统计总资源使用量，算出重写后的go版相比重写前的python版</summary>
      
    
    
    
    <category term="编程" scheme="https://jeff.wtf/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>批评者和被批评者的消亡</title>
    <link href="https://jeff.wtf/2018/08/the-critics/"/>
    <id>https://jeff.wtf/2018/08/the-critics/</id>
    <published>2018-08-04T16:03:26.000Z</published>
    <updated>2022-08-19T00:49:11.858Z</updated>
    
    <content type="html"><![CDATA[<p>网易云音乐给我随机播放到一首日本偶像团体的歌。翻一翻评论，看到粉丝在下面吵架。本来偶像团体的粉丝吵架是再正常不过（误），但是在我不熟悉这个团体的人看来，下面两边应该是同一批粉丝才对。</p><p>于是去问了一个是粉丝的朋友。他告诉我这个团体名字有汉字写法，又有假名写法，这两个名字可以把她们当成两个团来看。</p><p>在日本偶像行业这样经过充分竞争的市场，这样的事情好像很常见：杰尼斯的艺人之间，既要像是「一家人」的关系，亲密互动，又要是竞争对手，来制造话题和新闻；48系既要是一整个团体紧紧联系在一起，又要分地域、地域下分队伍、队伍间有小团体；46系外部要把48系当作官方对手，内部又要分团体、团体下居然还要分汉字写法还是假名写法。</p><p>这种做法几乎是偶像团体受欢迎的公式之一。这样做的目的一方面是为了话题性，所谓流量；另一方面还是为了保持竞争。竞争带来了批评，批评带来活力。</p><hr><p>之前看到游研社一篇文章写，腾讯游戏进入了天美和光子的双雄时代。</p><p>最近腾讯两款吃鸡手游的比拼看下来，光子的《刺激战场》相比天美的《全军出击》已经明显占据上风；更早的手游时代，光子的《全民超神》则是被天美的《王者荣耀》完败。</p><p>腾讯这样体量和实力的公司愿意投入资本，外加「吃鸡」或者「英雄联盟」这种IP，做出来的游戏，想不火应该都是很困难的。但腾讯还是要投入双倍的资源，让两个内部的工作室做一样题材的游戏出来。</p><p>正是因为「形势一片大好」，又缺乏外部竞争，不让两个内部工作室同时研发的后果就是没有办法知道游戏是不是做的足够好。引用游研社的一句话：</p><blockquote><p>相比市场外部，腾讯内部的竞争或许更为激烈。</p></blockquote><p>虽然两个工作室都是一家公司的，但出于利益最大化考虑的资本，更想看到两者充分的竞争。</p><p>如同开源世界中，Firefox团队会送给Chrome团队蛋糕，但也会批评Chrome的隐私策略；VS code团队和atom团队会借鉴对方的技术，但也会指出对方技术上的缺陷。</p><hr><p>前段时间《复仇者联盟3》大火的时候，有一个微博热门，内容是刘慈欣在一个采访里表示「一直不喜欢漫威电影」。</p><p>保证有人说「我不喜欢」的权利是很重要的。这是保证文化多样性的重要前提。</p><hr><p>美国作家怀特有这么一个说法：当代艺术和文学有一个很大的变化，那就是「批评家的消亡」。 </p><p>今天，批评者或许还在，但「被批评者」已经不存在了。</p><p>面对今天的批评者，今天的「被批评者」和其拥趸可以说你是外行，可以说你是同行来抹黑，可以怀疑你的立场和动机。批评者不再被当作批评者，而是被当作「攻击者」；那批评自然也不是批评，而是「攻击」。</p><p>知乎上有个问题问为什么现在辩论赛的观赏性变低了，有人回答说：</p><blockquote><p>辩论圈是这样的，看到有人说我不好，首先看这个人是谁，然后把他归入一个派别、团体，然后找出那个派别和我的利益冲突或者恩怨历史，然后终于得出这个人的动机，然后抛出他的黑点，也就是反击。至于这个人到底说了什么，有没有几分道理，who cares ？ </p><p>甚至就有很不错的辩手说，你们网民就是不配评论我们高贵的辩论赛。（类似于，你们知乎这些loser辩手不配……） </p><p>一个不接受批评的圈子，走下坡路，是天道。 </p></blockquote><p>在文化和艺术领域，资本似乎不需要批评的声音，反而能获取更大的利益。</p><hr><p>《西虹市首富》这个电影是最近的热门。大多数人是觉得好看的，但在即刻上刷到两则影评，都很长，觉得这部电影不好看。其中一篇还专门注明了，说知道大家都觉得好看，自己只是站在自己的角度做个影评。</p><p>结果还是被骂的体无完肤。评论有两个流派分别是：「你就是为了装X，故意搞特立独行」「就是优越感，好像众人皆醉我独醒」和「大家都觉得好看的不就是好电影了吗，讲这么多内涵干嘛」「电影院的都笑了就已经是好的喜剧电影了吗，我才不管他拍的好不好」。</p><p>别人一开口批评，就怀疑别人的动机，而不谈论别人的内容——这不是讨论问题的态度，是时刻准备吵架的态度。</p><hr><p>最近被讨论非常多的陈一发事件，争论的点主要是陈一发的视频是不是断章取义、或者陈一发到底有没有调侃和侮辱的意思、以及到底她是自己作死还是被人陷害这些事上。</p><p>在我看来，就陈一发这件事本身来说，她是错了；但是除开这个事本身，这个事情外发生的事性质更加恶劣：直接把她封禁，不再给她说话的机会。</p><p>可以直接堵住一个人的嘴，这是一件非常恶劣的事。</p><p>就像封禁PG One的时候大家纷纷叫好一样，封禁暴走漫画的时候大家骂声一片；封禁内涵段子的时候则是骂声叫好声都有。</p><p>不管大家在叫好还是叫骂，都改变不了这些事情性质的恶劣。封禁PG One和封禁暴走漫画、封禁内涵段子、封禁陈一发的性质都一样恶劣。</p><p>我想看到的，要么是有完整的法律法规，要么是有合理的执法过程，要么是有法庭上类似先例的判决。而不是悄无声息地抹杀，让人不能说话。</p><p>抹杀掉你讨厌的人，你还能跪在地上说「皇恩浩荡」；轮到自己头上时，才知道有多可怕。</p><hr><p>前天和扇贝一个同事聊了陈一发事件。</p><p>他赞同我的说法，一个人不应该悄无声息地被堵住嘴巴。</p><p>他在知乎是个小V。于是他在知乎的相应问题下回答，表达了这个观点。你可以说他是错的，可以批评他，但是不能堵住他的嘴不让他发声。</p><p>然后他的答案被知乎删除了。</p><hr><p>在被知乎堵上嘴之前，有很多人过来反驳他，基本是说封禁陈一发是斗鱼平台的决定，不是「国家意志」，跟其他封禁事件比起来，这件事是合理的。</p><p>然而前提是，摆在斗鱼面前的，是今年以来「暴走漫画」、「内涵段子」、「互联网视频整治」等等的前车之鉴。它不过是出于恐惧，做出了自我阉割。</p><p>知乎删掉这个回答，是一样的自我阉割。人不敢言，道路以目。</p><hr><p>「政治正确」似乎在席卷整个世界。</p><p>有一部分大环境的原因，想要找到优质的、新闻类型的中文内容是非常困难的。但是由于「政治正确」的笼罩，即使想要找到不政治敏感的时事话题的优质内容也是非常困难。</p><p>好奇心日报算是一个难得的优秀的媒体网站，有数据、能分析、有深度、还敢批评。</p><p>但是：<br><img src="/2018/08/the-critics/qdaily.png"></p><p>被批评者不存在了，批评者好像也在慢慢消失。</p><hr><p>若批评不自由，则赞美无意义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网易云音乐给我随机播放到一首日本偶像团体的歌。翻一翻评论，看到粉丝在下面吵架。本来偶像团体的粉丝吵架是再正常不过（误），但是在我不熟悉这个团体的人看来，下面两边应该是同一批粉丝才对。&lt;/p&gt;
&lt;p&gt;于是去问了一个是粉丝的朋友。他告诉我这个团体名字有汉字写法，又有假名写法，这</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>事情的复杂性</title>
    <link href="https://jeff.wtf/2018/07/complexity/"/>
    <id>https://jeff.wtf/2018/07/complexity/</id>
    <published>2018-07-26T16:25:50.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<p>最近换组频繁，昨天又被换回基础业务组，做扇贝单词相关的东西。</p><p>做基础业务，不太需要和「人」打交道，一下子睡眠好了很多，人也精神起来。</p><p>虽然前一个多月在阅读组做的也是比较基础的内容，主要和数据打交道，但和用户太相关，免不了数据结构和接口的设计需要和产品妥协。</p><p>而且在阅读这种业务场景下，数据最终的设计的合理性很大程度上取决于产品的想法：产品认为是A和B是一对多的结构，即使程序员认为不合理，也必须为它保留这样的结构；产品认为有用的功能，即程序员认为被使用到的次数很少，也需要为开发它付出很多时间。</p><p>相比之下，虽然单词这个项目最终设计出来的表结构也会反直觉，但它的合理性建立在一些有迹可循的标准上：问一下公司的英语老师，单词的拼写、发音、词典、释义、例句等等会有怎么样的常见情况和特殊情况，特殊情况的比例大约是多少。这样设计出的数据的结构与复杂多变的用户习惯关联不大，产品和程序员都很难有异议。</p><p>在阅读组，我遇到的问题是要处理一堆又一堆繁复的逻辑，一个又一个开不完的会；到单词组，我的问题只有一个：这些每秒数千请求的接口，怎么能让它变得更快更稳定。</p><hr><p>世界上有很多种不同的复杂的事情，不同的人会觉得不同的事情是复杂或简单。</p><p>经典定义下的理工科学生，会喜欢一类「复杂」问题，如：如何最快地从一亿个数里找出最小的一百万个？</p><p>这类问题的特点是：需要被定义的东西少、问题本身理解起来简单；它的解法却可能很复杂。</p><p>一个例子是费马大定理：「一般地将一个高于二次的幂分成两个同次幂之和，这是不可能的」。如此简单的一个问题定义，只要学过初等数学的人都能看懂。但它吸引了数百年无数数学家投入进去，直到1995年才被证明出来，还使用上了费马猜想提出后几百年以来发明出的更多的数学工具。</p><p>另一个例子是欧几里得的《几何原本》，仅仅在开头定义五条公理，然后推导出一整本书。所以《几何原本》既被叫做数学巨著，也被称为哲学巨著。</p><hr><p>我爱玩的游戏《Portal 2》就契合这类问题的特点：你只有一把能射出蓝光和橙光的枪；你身处一个有限的空间；你身边的道具永远只有那么几种；但在这些道具和空间的组合下，游戏制造出了非常多精妙的关卡。</p><p>我另一个喜欢的游戏《The Witness》也是这类游戏的典型：你只需要走路和画线，把线从起点连到终点。它的复杂性蕴藏在谜题的解法里，只有解决它时，玩家才会感受到乐趣。</p><p>传统的网络游戏就并非这类「复杂」问题。它们往往把复杂性放在规则上：给玩家很多选择；给玩家很多规则；玩家还可以和变化因素更多的「人」一起进行复杂规则下的游戏。这些网络游戏让你投入大量时间，体验到的是在掌握规则和被不定因素影响之间来回摆动的快感。</p><hr><p>把繁复的下层总结出来、屏蔽细节，为上层提供好用的工具&#x2F;结论&#x2F;接口，大概是数学、物理、计算机这些学科非常相似的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近换组频繁，昨天又被换回基础业务组，做扇贝单词相关的东西。&lt;/p&gt;
&lt;p&gt;做基础业务，不太需要和「人」打交道，一下子睡眠好了很多，人也精神起来。&lt;/p&gt;
&lt;p&gt;虽然前一个多月在阅读组做的也是比较基础的内容，主要和数据打交道，但和用户太相关，免不了数据结构和接口的设计需要和</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>个人的奋斗，历史的进程</title>
    <link href="https://jeff.wtf/2018/02/person-history/"/>
    <id>https://jeff.wtf/2018/02/person-history/</id>
    <published>2018-02-11T02:53:04.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="老家（一）"><a href="#老家（一）" class="headerlink" title="老家（一）"></a>老家（一）</h2><p>从2014年开始，我越来越不愿意回老家。每次回老家，我都会清晰地意识到两件事：</p><ul><li>中国仍然是一个第三世界国家，仍然是一个发展中国家</li><li>身边最普通的平民们、这些占中国人口一半的农民们，在饭桌上仍然是满嘴谎言的吹嘘者，在生活中仍然是缺乏合作能力、没有能力改变自己生活的第三世界人民</li></ul><p>这两个事实让我感到极其痛苦。关于第一个事实，我为这个地方地理位置、历史机遇不够好感到痛苦，为城市化进程还不够快感到痛苦；关于第二个事实，我为贫富差距大感到痛苦，为人性的懒惰和反智感到痛苦，为教育普及程度还不够感到痛苦。</p><p>这两个事实，一个是历史的进程，一个是个人的奋斗。历史的进程还没到，个人的奋斗还不够。</p><h2 id="南京（一）"><a href="#南京（一）" class="headerlink" title="南京（一）"></a>南京（一）</h2><p>在南京给合租的室友讲过这个事情，给他描述了我的痛苦。他表示理解。然后讲了一下他的意见。</p><p>关于老家城市化看不到希望的问题，他觉得由于历史和地理原因确实短时间看不到希望，但是政府的城市化进度已经很快，我应该期待那一天；关于老家的人反智、固执、难以适应现代商业社会的问题，他觉得这些是由于历史进程导致的在农村年纪稍大的人会有的问题，如果年轻人都是这样，才是一个真正的问题。</p><p>我并不觉得他真的能理解我、能理解这种痛苦。他是一个江苏人。我想即使是江苏的农村，也比我的老家生活水平高得多。</p><h2 id="老家（二）"><a href="#老家（二）" class="headerlink" title="老家（二）"></a>老家（二）</h2><p>我能记起来的在老家第一次因为这两个事实感到痛苦，是因为听到这里人放的音乐和谈话，感觉到一些人低俗的品味。当时我觉得他们不思进取、懒惰、文化水平低，品味低俗只是因此展示出的一个现象。</p><p>第二次可能是在夏天被脏茅厕的蚊子叮得不厌其烦、在晚上被床上大量的蚂蚁爬得浑身难受的时候。因为他们不作为，不尝试去用杀虫剂、电蚊香或者随便什么手段去提高自己的生活质量。当时我觉得他们总是在『战术上勤奋，战略上懒惰』，直接去解决问题而不去提升自己解决问题的手段或者借用更先进的工具，同时对生活质量也没有追求。</p><p>之后可能因为他们在饭桌上反智、反科学，可能因为他们对别人施加恶意、嘲笑别人，可能因为他们开不合时宜的玩笑，可能因为他们随便用自己的标准评价别人，可能因为他们固执好面子而无法合作……等等等等，而感到愤怒和痛苦过。总之，都是个人的行为让我感觉痛苦，但这些个人行为往往也是普遍的现象。</p><p>有些人爱说『穷山恶水出刁民』，其实就像我的想法一样，把这种恶归咎于个人，忽略了大的历史背景。用马克思那一套来讲，就是忽略了客观事实，只讲人的主观能动性。但人的主观能动性是有限的，让我感觉痛苦的这些原因，其实都有其历史背景的原因。比如不思进取、文化水平低，是因为几十年前的中国教育普及还不够，人民生活也很穷，支付不起教育的费用；比如不使用更先进的工具、对生活质量没有追求，是因为农民的收入水平还很低，离所谓『小康』还差一大截；比如随意评价别人、对人施加恶意，只是因为农民们自己的生活也还不够幸福罢了，需要这些来调剂生活；比如固执好面子、难以适应现代合作，是以上这些原因的结合，带来的历史惯性。</p><p>就群体来看，由个人组成的群体的整体行为当然是因为历史大环境决定的。但就个人来说，一些人可以发挥自己的主观能动性，凭借个人的奋斗逃离这个环境。</p><p>仔细想一下，这个地区的历史环境应该并不会让我这样的平民老百姓感到痛苦，真正让我痛苦的事情，其实是自己在老家的亲人都是被大环境决定的群体中的一个。</p><h2 id="南京（二）"><a href="#南京（二）" class="headerlink" title="南京（二）"></a>南京（二）</h2><p>我和这位南京室友聊过很多东西。聊过自己有一些遗憾的东西。</p><p>我说，即使像我们两个上过大学受过高等教育，从小生活里各种物质资源也很丰富，尚且会觉得『这个事情没做过，那个东西没试过，挺遗憾的』，那我奶奶这样，八十多了，连自己名字都不会写，连手机都不会玩。她会不会，有的时候觉得非常痛苦？会不会在夜深人静的时候，她也想去试试这些事情？会不会觉得自己这一生实在实在太遗憾？</p><p>他说，应该不会，一是作为这个年纪的老人，他们心态可能已经适应了这些变化，不会为这些做不到的事感到痛苦；二是一个人不会因为自己不知道的事情感觉痛苦，很多东西他们不知道，也不知道自己不知道这件事，因此完全不会为这些事感觉烦恼。有的时候，知道得多反而才是痛苦的。</p><p>不知道是不是为了让自己好受一点，我觉得他说的很对。</p><p>可能是乔布斯说过，用户们不知道真正自己想要的是什么。很多时候，一个需求出现之后，它才成为了一个需求。</p><p>但是在信息已经非常发达的今天，很多第三世界国家的人能看见丰富的物质世界了，他们也感觉羡慕，也想和发达国家的人一样过上那样物质丰富的好生活。但是他们做不到，这时他们感觉痛苦了。</p><p>我常常想，中国是一个国家，但内部的差别好像是几个世界：一二线城市像发达国家那样发达，穷乡僻壤的生活条件还非常落后。个人精神上的差异和物质上的差异一样大。</p><h2 id="老家（三）"><a href="#老家（三）" class="headerlink" title="老家（三）"></a>老家（三）</h2><p>我觉得奶奶应该已经感受到这种物质差异带来的痛苦了。</p><p>老家已经没什么青壮年常住了，年轻人都会外出打工。每年都会有人赚了足够的钱，开着车回来，给父母建大的楼房。布局要按照城市里的，有干净的卫生间、用燃气的厨房、24小时热水的热水器、大电视、空调、瓷砖地板……</p><p>这些在物质上领先老家农村体系好几代的东西，被一次性打包带了回来。它们剧烈地撞击着每一间用泥巴和红砖搭积木一样搭起来的旧房子。旧房子和里面的旧家具旧格局一起倒塌；隔壁四邻都建了新房，新建的房子一个比一个大，一个比一个高。</p><p>等啊等，在今年，奶奶终于还是等到了新房子，不过比别人的矮，比别人的小；家具和装修也很拮据。</p><p>奶奶是一个很善良的人。今年回来，她整天都要不停地帮忙，不知道在忙的事情是不是真的有意义；有的时候很她不开心；有的时候会表现出来对别人家的嫉妒，有的时候会愤怒。</p><p>实际上，她的儿子们，有的毫无作为，有的大起之后大落，有的负债累累。但在这个时候建这个新房子，是一件不得不完成的事。</p><h2 id="南京（三）"><a href="#南京（三）" class="headerlink" title="南京（三）"></a>南京（三）</h2><p>和他说过，我老家这边建房，就真的和初中语文课本里的《台阶》这篇文章一样。『我们家的台阶低！』，课文里出现的这句话，真的也会从我奶奶嘴里说出来。</p><p>他说没有见过这篇课文。因为他是江苏人，用苏教版，我用的是人教版。</p><h2 id="老家（四）"><a href="#老家（四）" class="headerlink" title="老家（四）"></a>老家（四）</h2><p>虽然精神上不见得已经有了变化，但物质上的追求使得这边的『个人』们『奋斗』起来了。精神上还需要等待『历史的进程』。至少随着物质的丰富，精神上的富足也是一件看起来有希望的事。</p><p>而让我奶奶痛苦的，不是历史大环境的变迁，而是她的孩子们，是这个进程中掉队的几个人。</p><h2 id="南京（四）"><a href="#南京（四）" class="headerlink" title="南京（四）"></a>南京（四）</h2><p>有的时候我会耍嘴皮子，对于我做到了但是他没做到的事，我会说：『不仅要看历史的进程，也要看个人的奋斗』；对于我做不到的事，我就会说『不仅要看个人的奋斗，也要看历史的进程』。</p><p>之前对这种行为自己觉得很可笑，会把自己叫『精致的利己主义者』。现在想想其实是有点道理的：『个人的奋斗』和『历史的进程』虽然像辩证法里的两面，分析一个事情的时候，两者像两个维度一样要去分析；但是它们确实是在相互依赖，互相影响。</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>『历史的进程』并没有给出有利的条件，被它影响的『个人的奋斗』又很缺乏。这是奶奶痛苦的根源。她比我更痛苦的原因是，我觉得我还大有前途，但她已经八十多了。</p><p>我常常会想象老人面对死亡的感受。我的这个自我意识会消失么？我应该怎么和这个世界告别？能不能让我的意识多活一天？我应该做了什么才会心满意足的完全消失？宗教？信仰？</p><p>我在想，突然离世的人可能最多只是肉体上瞬时的痛苦，而老到身体不能承受而去世的人，是不是每天都会面对这些问题的煎熬？</p><p>生前不管身后事。我这样的想法是对老人家的不尊重，用老家的说法是不吉利。但我阻止不了自己去思考这些事。看到奶奶每天不停地帮忙工作，就会自然想到，她是不是也考虑到了和我一样的问题？是不是在抢自己的时间？</p><p>我告诉奶奶，『公司给我毕业之后开的年薪很高，一年xx万呢！』，我在她面前炫富，希望她能觉得，挣钱已经不是那么困难了，我作为她的孙子，在物质和精神上都很富足，和别人的差距并不大了。能不能让她稍微不那么痛苦一点呢？</p><p>这个年薪在老家建个大房子应该绰绰有余了吧。但是我还有半年才能毕业，毕业后不知道一年还是两年还是三年能攒够这个钱，不知道奶奶还有没有时间等我。个人的奋斗终究是有限的，希望这个部分的历史进程能稍微走慢一点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;老家（一）&quot;&gt;&lt;a href=&quot;#老家（一）&quot; class=&quot;headerlink&quot; title=&quot;老家（一）&quot;&gt;&lt;/a&gt;老家（一）&lt;/h2&gt;&lt;p&gt;从2014年开始，我越来越不愿意回老家。每次回老家，我都会清晰地意识到两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中国仍然是</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>jeff.wtf的第一篇文章</title>
    <link href="https://jeff.wtf/2017/11/jeff-wtf-first/"/>
    <id>https://jeff.wtf/2017/11/jeff-wtf-first/</id>
    <published>2017-11-25T16:19:13.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>为了淘宝送的手机卡买了台手机。</p></li><li><p>为了外卖送的鸡蛋买了个火锅。</p></li><li><p>为了一个域名又搭了个博客。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为了淘宝送的手机卡买了台手机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了外卖送的鸡蛋买了个火锅。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了一个域名又搭了个博客。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O 多路复用入门——select/poll/epoll</title>
    <link href="https://jeff.wtf/2017/02/IO-multiplexing/"/>
    <id>https://jeff.wtf/2017/02/IO-multiplexing/</id>
    <published>2017-02-11T12:43:14.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要-I-x2F-O-多路复用"><a href="#为什么要-I-x2F-O-多路复用" class="headerlink" title="为什么要 I&#x2F;O 多路复用"></a>为什么要 I&#x2F;O 多路复用</h3><p>当需要从一个叫 <code>r_fd</code> 的描述符不停地读取数据，并把读到的数据写入一个叫 <code>w_fd</code> 的描述符时，我们可以用循环使用阻塞 I&#x2F;O ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = read(r_fd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(write(w_fd, buf, n) != n)</span><br><span class="line">        err_sys(<span class="string">&quot;write error&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是，如果要从两个地方读取数据呢？这时，不能再使用会把程序阻塞住的 <code>read</code> 函数。因为可能在阻塞地等待 <code>r_fd1</code> 的数据时，来不及处理 <code>r_fd2</code>，已经到达的 <code>r_fd2</code> 的数据可能会丢失掉。</p><p>这个情况下需要使用<strong>非阻塞 I&#x2F;O</strong>。</p><p>只要做个标记，把文件描述符标记为非阻塞的，以后再对它使用 <code>read</code> 函数：如果它还没有数据可读，函数会立即返回并把 errorno 这个变量的值设置为 35，于是我们知道它没有数据可读，然后可以立马去对其他描述符使用 <code>read</code>；如果它有数据可读，我们就读取它数据。对所有要读的描述符都调用了一遍 <code>read</code> 之后，我们可以等一个较长的时间（比如几秒），然后再从第一个文件描述符开始调用 <code>read</code> 。这种循环就叫做<strong>轮询</strong>（polling）。</p><p>这样，不会像使用阻塞 I&#x2F;O 时那样因为一个描述符 <code>read</code> 长时间处于等待数据而使程序阻塞。</p><p>轮询的缺点是浪费太多 CPU 时间。大多数时候我们没有数据可读，但是还是用了 <code>read</code> 这个<strong>系统调用</strong>，使用系统调用时会从用户态切换到内核态。而大多数情况下我们调用 <code>read</code>，然后陷入内核态，内核发现这个描述符没有准备好，然后切换回用户态并且只得到 EAGAIN （errorno 被设置为 35），做的是无用功。描述符非常多的时候，每次的切换过程就是巨大的浪费。</p><p>所以，需要 <strong>I&#x2F;O 多路复用</strong>。I&#x2F;O 多路复用通过使用一个系统函数，同时等待多个描述符的可读、可写状态。</p><p>为了达到这个目的，我们需要做的是：建立一个描述符列表，以及我们分别关心它们的什么事件（可读还是可写还是发生例外情况）；调用一个系统函数，直到这个描述符列表里有至少一个描述符关联的事件发生时，这个函数才会返回。</p><p>select, poll, epoll 就是这样的系统函数。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>我们可以在所有 POSIX 兼容的系统里使用 select 函数来进行 I&#x2F;O 多路复用。我们需要通过 select 函数的参数传递给内核的信息有：</p><ul><li>我们关心哪些描述符</li><li>我们关心它们的什么事件</li><li>我们希望等待多长时间</li></ul><p>select 的返回时，内核会告诉我们：</p><ul><li>可读的描述符的个数</li><li>哪些描述符发生了哪些事件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">int select(int maxfdp1, fd_set* readfds,</span><br><span class="line">           fd_set* writefds, fd_set* exceptfds,</span><br><span class="line">           struct timeval* timeout);</span><br><span class="line"></span><br><span class="line">// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</span><br></pre></td></tr></table></figure><p><code>maxfdp1</code> 意思是 “max file descriptor plus 1” ，就是把你要监视的所有文件描述符里最大的那个加上 1 。（它实际上决定了内核要遍历文件描述符的次数，比如你监视了文件描述符 5 和 20 并把 <code>maxfdp1</code> 设置为 21 ，内核每次都会从描述符 0 依次检查到 20。）</p><p>中间的三个参数是你想监视的文件描述符的集合。可以把 fd_set 类型视为 1024 位的二进制数，这意味着 select 只能监视小于 1024 的文件描述符（1024 是由 Linux 的 sys&#x2F;select.h 里 <code>FD_SETSIZE</code> 宏设置的值）。在 select 返回后我们通过 <code>FD_ISSET</code> 来判断代表该位的描述符是否是已准备好的状态。</p><p>最后一个参数是等待超时的时长：到达这个时长但是没有任一描述符可用时，函数会返回 0 。</p><p>用一个代码片段来展示 select 的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化两个 fd_set 以及 timeval</span></span><br><span class="line">fd_set read_set, write_set;</span><br><span class="line">FD_ZERO(read_set);</span><br><span class="line">FD_ZERO(write_set);</span><br><span class="line">timeval t;</span><br><span class="line">t.tv_sec = <span class="number">5</span>;   <span class="comment">// 超时为 5 秒</span></span><br><span class="line">t.tv_usec = <span class="number">0</span>;  <span class="comment">// 加 0 微秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置好两个 fd_set</span></span><br><span class="line"><span class="type">int</span> fd1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> fd2 = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> fd3 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> maxfdp1 = <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">FD_SET(fd1, &amp;read_set);</span><br><span class="line">FD_SET(fd2, &amp;read_set);</span><br><span class="line">FD_SET(fd2, &amp;write_set);</span><br><span class="line">FD_SET(fd3, &amp;write_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备备用的 fd_set</span></span><br><span class="line">fd_set r_temp = read_set;</span><br><span class="line">fd_set w_temp = write_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 每次都要重新设置放入 select 的 fd_set</span></span><br><span class="line">    read_set = r_temp;</span><br><span class="line">    write_set = w_temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 select</span></span><br><span class="line">    <span class="type">int</span> n = select(maxfdp1, &amp;read_set, &amp;write_set, <span class="literal">NULL</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的 select 函数会一直阻塞，直到</span></span><br><span class="line">    <span class="comment">// 3, 4 可读以及 4, 5 可写这四件事中至少一项发生</span></span><br><span class="line">    <span class="comment">// 或者等待时间到达 5 秒，返回 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;maxfdp1 &amp;&amp; n&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(i, &amp;read_set))&#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(i==fd1)</span><br><span class="line">                prinf(<span class="string">&quot;描述符 3 可读&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==fd2)</span><br><span class="line">                prinf(<span class="string">&quot;描述符 4 可读&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(i, &amp;write_set))&#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(i==fd2)</span><br><span class="line">                prinf(<span class="string">&quot;描述符 3 可写&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==fd3)</span><br><span class="line">                prinf(<span class="string">&quot;描述符 4 可写&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的 printf 语句换成对应的 read 或者 write 函数就</span></span><br><span class="line">    <span class="comment">// 可以立即读取或者写入相应的描述符而不用等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，select 的缺点有：</p><ul><li>默认能监视的文件描述符不能大于 1024，也代表监视的总数不超过1024。即使你因为需要监视的描述符大于 1024 而改动内核的 <code>FD_SETSIZE</code> 值，但由于 select 是每次都会线性扫描整个fd_set，集合越大速度越慢，所以性能会比较差。</li><li>select 函数返回时只能看见已准备好的描述符数量，至于是哪个描述符准备好了需要循环用 <code>FD_ISSET</code> 来检查，当未准备好的描述符很多而准备好的很少时，效率比较低。</li><li>select 函数每次执行的时候，都把参数里传入的三个 fd_set 从用户空间复制到内核空间。而每次 fd_set 里要监视的描述符变化不大时，全部重新复制一遍并不划算。同样在每次都是未准备好的描述符很多而准备好的很少时，调用 select 会很频繁，用户&#x2F;内核间的的数据复制就成了一个大的开销。</li></ul><p>还有一个问题是在代码的写法上给我一些困扰的，就是每次调用 select 前必须重新设置三个 fd_set。 fd_set 类型只是 1024 位的二进制数（实际上结构体里是几个 long 变量的数组；比如 64 位机器上 long 是 64 bit，那么 fd_set 里就是 16 个 long 变量的数组），由一位的 1 和 0 代表一个文件描述符的状态，但是其实调用 select 前后位的 1&#x2F;0 状态意义是不一样的。</p><p>先讲一下几个对 fd_set 操作的函数的作用：<code>FD_ZERO</code> 把 fd_set 所有位设置为 0 ；<code>FD_SET</code> 把一个位设置为 1 ；<code>FD_ISSET</code> 判断一个位是否为 1 。</p><p>调用 select 前：我们用 <code>FD_ZERO</code> 把 fd_set 先全部初始化，然后用 <code>FD_SET</code> 把我们关心的代表描述符的位设置为 1 。我们这时可以用 <code>FD_ISSET</code> 判断这个位是否被我们设置，这时的含义是<strong>我们想要监视的描述符是否被设置为被监视的状态</strong>。</p><p>调用 select 时：内核判断 fd_set 里的位并把各个 fd_set 里所有值为 1 的位记录下来，然后把 fd_set 全部设置成 0 ；一个描述符上有对应的事件发生时，把对应 fd_set 里代表这个描述符的位设置为 1 。</p><p>在 select 返回之后：我们同样用 <code>FD_ISSET</code> 判断各个我们关心的位是 0 还是 1 ，这时的含义是，<strong>这个位是否是发生了我们关心的事件</strong>。</p><p>所以，在下一次调用 select 前，我们不得不把已经被内核改掉的 fd_set 全部重新设置一下。</p><p>select 在监视大量描述符尤其是更多的描述符未准备好的情况时性能很差。《Unix 高级编程》里写，用 select 的程序通常只使用 3 到 10 个描述符。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 和 select 是相似的，只是给的接口不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</span></span><br></pre></td></tr></table></figure><p><code>fdarray</code> 是 <code>pollfd</code> 的数组。<code>pollfd</code> 结构体是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 我期待的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件：我期待的事件中发生的；或者异常情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>nfds</code> 是 <code>fdarray</code> 的长度，也就是 pollfd 的个数。</p><p><code>timeout</code> 代表等待超时的毫秒数。</p><p>相比 select ，poll 有这些优点：由于 poll 在 pollfd 里用 <code>int fd</code> 来表示文件描述符而不像 select 里用的 fd_set 来分别表示描述符，所以没有必须小于 1024 的限制，也没有数量限制；由于 poll 用 <code>events</code> 表示期待的事件，通过修改 <code>revents</code> 来表示发生的事件，所以不需要像 select 在每次调用前重新设置描述符和期待的事件。</p><p>除此之外，poll 和 select 几乎相同。在 poll 返回后，需要遍历 <code>fdarray</code> 来检查各个 <code>pollfd</code> 里的 <code>revents</code> 是否发生了期待的事件；每次调用 poll 时，把 <code>fdarray</code> 复制到内核空间。在描述符太多而每次准备好的较少时，poll 有同样的性能问题。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是在 Linux 2.5.44 中首度登场的。不像 select 和 poll ，它提供了三个系统函数而不是一个。</p><h4 id="epoll-create-用来创建一个-epoll-描述符："><a href="#epoll-create-用来创建一个-epoll-描述符：" class="headerlink" title="epoll_create 用来创建一个 epoll 描述符："></a>epoll_create 用来创建一个 epoll 描述符：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：epoll 描述符</span></span><br></pre></td></tr></table></figure><p><code>size</code> 用来告诉内核你想监视的文件描述符的数目，但是它<strong>并不是限制了能监视的描述符的最大个数</strong>，而是给内核最初分配的空间一个建议。然后系统会在内核中分配一个空间来存放事件表，并返回一个 <strong>epoll 描述符</strong>，用来操作这个事件表。</p><h4 id="epoll-ctl-用来增-x2F-删-x2F-改内核中的事件表："><a href="#epoll-ctl-用来增-x2F-删-x2F-改内核中的事件表：" class="headerlink" title="epoll_ctl 用来增&#x2F;删&#x2F;改内核中的事件表："></a>epoll_ctl 用来增&#x2F;删&#x2F;改内核中的事件表：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：成功时返回 0 ，失败时返回 -1</span></span><br></pre></td></tr></table></figure><p><code>epfd</code> 是 epoll 描述符。</p><p><code>op</code> 是操作类型（增加&#x2F;删除&#x2F;修改）。</p><p><code>fd</code> 是希望监视的文件描述符。</p><p><code>event</code> 是一个 epoll_event 结构体的指针。epoll_event 的定义是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>        *ptr;</span><br><span class="line">   <span class="type">int</span>          fd;</span><br><span class="line">   <span class="type">uint32_t</span>     u32;</span><br><span class="line">   <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">   <span class="type">uint32_t</span>     events;      <span class="comment">// 我期待的事件</span></span><br><span class="line">   <span class="type">epoll_data_t</span> data;        <span class="comment">// 用户数据变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体里，除了期待的事件外，还有一个 <code>data</code> ，是一个 union，它是用来让我们在得到下面第三个函数的返回值以后方便的定位文件描述符的。</p><h4 id="epoll-wait-用来等待事件"><a href="#epoll-wait-用来等待事件" class="headerlink" title="epoll_wait 用来等待事件"></a>epoll_wait 用来等待事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *result_events,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1</span></span><br></pre></td></tr></table></figure><p><code>epfd</code> 是 epoll 描述符。</p><p><code>result_events</code> 是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义。</p><p><code>maxevents</code> 是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数。</p><p><code>timeout</code> 是等待超时的毫秒数。</p><p>用一个代码片段来展示 epoll 的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 epoll_create 创建 epoll 描述符 */</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> fd2 = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> fd3 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 epoll_ctl 注册好四个事件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev1</span>;</span></span><br><span class="line">ev1.events = EPOLLIN;      <span class="comment">// 期待它的可读事件发生</span></span><br><span class="line">ev1.data   = fd1;          <span class="comment">// 我们通常就把 data 设置为 fd ，方便以后查看</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev1);  <span class="comment">// 添加到事件表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev2</span>;</span></span><br><span class="line">ev2.events = EPOLLIN;</span><br><span class="line">ev2.data   = fd2;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev2);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev3</span>;</span></span><br><span class="line">ev3.events = EPOLLOUT;     <span class="comment">// 期待它的可写事件发生</span></span><br><span class="line">ev3.data   = fd2;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev3);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev4</span>;</span></span><br><span class="line">ev4.events = EPOLLOUT;</span><br><span class="line">ev4.data   = fd3;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd3, &amp;ev4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 epoll_wait 等待事件 */</span></span><br><span class="line"># DEFINE MAXEVENTS <span class="number">4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">result_events</span>[<span class="title">MAXEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epfd, &amp;result_events, MAXEVENTS, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; n--)&#123;</span><br><span class="line">        <span class="comment">// result_events[i] 一定是 ev1 到 ev4 中的一个</span></span><br><span class="line">        <span class="keyword">if</span>(result_events[i].events&amp;EPOLLIN)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;描述符 %d 可读&quot;</span>, result_events[i].fd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result_events[i].events&amp;EPOLLOUT)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;描述符 %d 可写&quot;</span>, result_events[i].fd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 epoll 解决了 poll 和 select 的问题：</p><ul><li><p>只在 epoll_ctl 的时候把数据复制到内核空间，这保证了每个描述符和事件一定只会被复制到内核空间一次；每次调用 epoll_wait 都不会复制新数据到内核空间。相比之下，select 每次调用都会把三个 fd_set 复制一遍；poll 每次调用都会把 <code>fdarray</code> 复制一遍。</p></li><li><p>epoll_wait 返回 n ，那么只需要做 n 次循环，可以保证遍历的每一次都是有意义的。相比之下，select 需要做至少 n 次至多 <code>maxfdp1</code> 次循环；poll 需要遍历完 fdarray 即做 <code>nfds</code> 次循环。</p></li><li><p>在内部实现上，epoll 使用了回调的方法。调用 epoll_ctl 时，就是注册了一个事件：在集合中放入文件描述符以及事件数据，并且加上一个回调函数。一旦文件描述符上的对应事件发生，就会调用回调函数，这个函数会把这个文件描述符加入到<strong>就绪队列</strong>上。当你调用 epoll_wait 时，它只是在查看就绪队列上是否有内容，有的话就返回给你的程序。<code>select()</code> <code>poll()</code> <code>epoll_wait()</code> 三个函数在操作系统看来，都是睡眠一会儿然后判断一会儿的循环，但是 select 和 poll 在醒着的时候要遍历整个文件描述符集合，而 epoll_wait 只是看看就绪队列是否为空而已。这是 epoll 高性能的理由，使得其 I&#x2F;O 的效率不会像使用轮询的 select&#x2F;poll 随着描述符增加而大大降低。</p></li></ul><blockquote><p>注 1 ：select&#x2F;poll&#x2F;epoll_wait 三个函数的等待超时时间都有一样的特性：等待时间设置为 0 时函数不阻塞而是立即返回，不论是否有文件描述符已准备好；poll&#x2F;epoll_wait 中的 timeout 为 -1，select 中的 timeout 为 NULL 时，则无限等待，直到有描述符已准备好才会返回。</p></blockquote><blockquote><p>注 2 ：有的新手会把文件描述符是否标记为阻塞 I&#x2F;O 等同于 I&#x2F;O 多路复用函数是否阻塞。其实文件描述符是否标记为阻塞，决定了你 <code>read</code> 或 <code>write</code> 它时如果它未准备好是阻塞等待，还是立即返回 EAGAIN ；而 I&#x2F;O 多路复用函数除非你把 timeout 设置为 0 ，否则它总是会阻塞住你的程序。</p></blockquote><blockquote><p>注 3 ：上面的例子只是入门，可能是不准确或不全面的：一是数据要立即处理防止丢失；二是 EPOLLIN&#x2F;EPOLLOUT 不完全等同于可读可写事件，具体要去搜索 poll&#x2F;epoll 的事件具体有哪些；三是大多数实际例子里，比如一个 tcp server ，都会在运行中不断增加&#x2F;删除的文件描述符而不是记住固定的 3 4 5 几个描述符（用这种例子更能看出 epoll 的优势）；四是 epoll 的优势更多的体现在处理大量闲连接的情况，如果场景是处理少量短连接，用 select 反而更好，而且用 select 的代码能运行在所有平台上。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么要-I-x2F-O-多路复用&quot;&gt;&lt;a href=&quot;#为什么要-I-x2F-O-多路复用&quot; class=&quot;headerlink&quot; title=&quot;为什么要 I&amp;#x2F;O 多路复用&quot;&gt;&lt;/a&gt;为什么要 I&amp;#x2F;O 多路复用&lt;/h3&gt;&lt;p&gt;当需要从一个叫 </summary>
      
    
    
    
    <category term="编程" scheme="https://jeff.wtf/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>老人的囤积综合征</title>
    <link href="https://jeff.wtf/2016/12/diogenes/"/>
    <id>https://jeff.wtf/2016/12/diogenes/</id>
    <published>2016-12-23T06:59:09.000Z</published>
    <updated>2022-08-16T14:08:06.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>囤积症或储物症（英文： Compulsive hoarding，或强迫性囤积症、病态性囤积症、弃置恐惧症），一种强迫行为，过度性地收购或收集物件，即使是不值钱、有危险性或不卫生的物品。</p><p>——维基百科</p></blockquote><blockquote><p>第欧根尼综合症，又名肮脏混乱综合症或众议院综合征。主要出现在老年人上，有时伴随老年痴呆症。</p><p>——百度百科</p></blockquote><hr><p>我第一次听说这种疾病的时候是很恐慌的。因为我的奶奶有类似这些症状的行为。</p><p>我一直把老人舍不得扔掉东西、甚至主动囤积的行为解释为老一辈人看到物品的价值和我们不一样。比如我看到这是一盘吃不完的剩菜，价值10块钱，扔掉没什么大不了，应该被扔掉了；老人看到的却不一样，他们看到，这是一盘剩菜，它的作料长在地里，它的食材在另一个地方被养殖，盘底的植物油是被压榨出来的。</p><p>他们站在这个立场上，对一个物品的价值判断和我们完全不同。主动囤积也是这个原因。</p><p>后来，我有了新的猜测。虽然有点悲哀，但它是可能的。</p><p>这个理由同样是由于立场带来的价值判断的区别。审视一个物品的时候，老人和我们看到这个物品剩余的价值不同。</p><p>我们看到一盘剩菜，想到的是：没有人会需要它了，它应该被扔掉。老人看到一盘剩菜的时候，想到的是：它还有部分可以被食用，它应该被留下。</p><p>这是立场问题，因为老人就像一盘剩菜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;囤积症或储物症（英文： Compulsive hoarding，或强迫性囤积症、病态性囤积症、弃置恐惧症），一种强迫行为，过度性地收购或收集物件，即使是不值钱、有危险性或不卫生的物品。&lt;/p&gt;
&lt;p&gt;——维基百科&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>看操作系统有感：战略上的勤奋</title>
    <link href="https://jeff.wtf/2016/12/think-os/"/>
    <id>https://jeff.wtf/2016/12/think-os/</id>
    <published>2016-12-20T08:15:02.000Z</published>
    <updated>2022-08-16T14:08:06.508Z</updated>
    
    <content type="html"><![CDATA[<p>前天看<a href="https://chyyuu.gitbooks.io/ucorebook/content/zh/preface/osabstract.html">一本 Gitbook </a>，说操作系统有四个基本抽象：中断、进程、虚存、文件，它们是操作系统设计的基础。</p><p>为什么一定要有这四个基本抽象？我想谈谈自己浅薄的理解以及感想。</p><h4 id="为什么一定要有进程的存在？"><a href="#为什么一定要有进程的存在？" class="headerlink" title="为什么一定要有进程的存在？"></a>为什么一定要有进程的存在？</h4><p>目的大家都知道：为了让单个处理机同时处理多个有独立功能的任务、尽量提高处理机的利用率。</p><p>如果大家没有选择让操作系统来统筹调度多任务的话，计算机行业会选择什么样的替代方案？</p><p>我能想到的方案是用更多的处理机，一个处理机当然只做一个任务。发展到今天，可能会是这样的情况：今天我去买了 intel 最新的 256 核处理器，可以同时处理更多的任务；新的单机游戏 GTA5 要求至少128核处理器才能跑起来，因为它有 80 个线程在工作。诸如此类。</p><p>但是计算机行业的选择并不是这样！我们把复杂的逻辑加在操作系统上，发明进程这个概念，让单个处理机同时处理更多的任务。</p><p>有句话经常被用来嘲讽不停“学习”却成绩差的“笨”学生：不要用战术上的勤奋，掩饰战略上的懒惰。计算机的发展正是如此。很多问题有简单粗暴的解决办法也有复杂巧妙的解决办法。简单粗暴比如进程没有被设计出来，大家需要依赖行业发展出多核处理器；比如项目性能不行，我们要依赖加钱加机器。复杂巧妙则是在现有的技术条件下对运作方式进行改良。</p><p>假如计算机行业的发展是简单粗暴的，那么虚存、文件系统都是这样：</p><ul><li><p>虚存的存在是为了实现三件事：让内存看起来更大、让程序使用看起来连续的地址空间、让各个程序使用的内存互相隔离。如果没有用虚存这个方案，简单粗暴的“操作系统”将会：给程序分配连续固定且足够大的空间。这样利用率相比现在低了很多，不够的时候怎么办？加内存。</p></li><li><p>文件系统也是如此，简单粗暴的“操作系统”让数据连续摆放，没有分块这种事情存在，你看到的数据的顺序和物理上一致。不够的时候怎么办，加硬盘。</p></li></ul><p>计算机行业用战略上的勤奋，让我们有了今天这样复杂的操作系统和廉价的个人电脑。</p><h4 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h4><p>把目光向上加一层。</p><p>我自己的操作系统课本里有“用户态线程”这个概念，解释为不能被操作系统感知的线程，和我们常说的“线程”有很大不同。按照这个概念，协程就是用户态线程。每个协程有自己独立的上下文，可以在当中被切入切出。不过这个调度不是由操作系统来做的（操作系统根本无法感知），Python 的协程让用户来做显式的切换，Go 语言则是在语言级别有一个调度器。</p><p>再抽象一点，用到回调的编程方法时，系统向程序通知一个事件，程序让出当前的顺序的代码的执行权，进入设置好的回调函数的栈上下文，也是一个独立的“用户态线程”。只不过它的入口和出口固定了。</p><p>WEB 后端编程喜欢用多线程，来一个请求，就开启一个独立的线程。开一个新线程是很简单的事，当它阻塞的时候就让它阻塞好了，因为操作系统很聪明，它发现这个线程阻塞了，然后会把处理机的执行权和上下文切换为其它线程。但是量足够大时，线程的创建和销毁是很大的开销，因为这两件事要经历内核态和用户态的切换。于是我们有 I&#x2F;O 多路复用，我们有线程池，减少这个开销。但是量再大时，到 C10K 问题的出现，则是线程的切换成本已经成为了巨大的负担。</p><p>我认为不停地开线程，就是战略上的懒惰。使用协程（或者用户态线程）则是战略上的勤奋，它把切换的工作交给了自己而不是操作系统。当我执行一个网络或者文件操作时，我知道马上会是阻塞的，于是标记一下，然后立马切到其他上下文中执行其他协程；这个操作标记完成时，再在其他协程让出执行权时切换回来。这样，协程不需要像系统线程一样保有优先级以及多核的负载均衡等信息，也不需要在切换协程时在内核态和用户态之间切换。复杂了自己程序的逻辑，节省了负担。</p><p>不用战术上的勤奋，掩饰战略上的懒惰。“战术上的勤奋”是各种意义上资源的浪费，战略上的勤奋则是资源的节约。所以今天高科技的各种廉价，感谢商业的法则，感谢计算机行业的人才，也期待 Go 语言以及各种自带“用户态线程”语言的前途。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前天看&lt;a href=&quot;https://chyyuu.gitbooks.io/ucorebook/content/zh/preface/osabstract.html&quot;&gt;一本 Gitbook &lt;/a&gt;，说操作系统有四个基本抽象：中断、进程、虚存、文件，它们是操作系统设计的基</summary>
      
    
    
    
    <category term="计算机" scheme="https://jeff.wtf/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>局部变量在Python闭包中遇到的一些麻烦</title>
    <link href="https://jeff.wtf/2016/11/local-var-in-python-closure/"/>
    <id>https://jeff.wtf/2016/11/local-var-in-python-closure/</id>
    <published>2016-11-20T06:08:30.000Z</published>
    <updated>2022-10-18T00:30:54.548Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python作用域的一些麻烦"><a href="#Python作用域的一些麻烦" class="headerlink" title="Python作用域的一些麻烦"></a>Python作用域的一些麻烦</h3><p>Python 的作用域有这样的规则，你在内部的局部作用域里，仅仅使用外部的变量是允许的，但是改变这个引用本身是不被允许的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    v = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        t = v + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(t)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>上面的代码是没有错误的， v 被认为是外部作用域的变量，引用它是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    v = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        v = <span class="number">3</span></span><br><span class="line">        v += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>上面也是没有错误的， v 被定义为内部作用域的变量，对它的操作和外部的 v 无关。</p><p>但是，这样是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    v = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        t = v + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(t)</span><br><span class="line">        v = t</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>上面的例子里，执行<code>t = v + 1</code>这一行时会报错，因为这个作用域里有改变 v 本身的操作：<code>v = t</code>，所以 v 被认为是一个内部的变量，而我们并不能在这个作用域里找到它的定义。</p><p>这个时候需要使用 <code>nonlocal</code> 关键字，把 v 声明为外部作用域的变量：</p><p><em>（ Python2 并没有 nonlocal 关键字，所以没有办法在内部的局部作用域改变外部的局部作用域的变量本身。当然可以使用可变对象如 list 来模拟这样的效果，但你仍旧不能修改这个引用本身指向的对象。）</em></p><p><em>（同理，局部作用域里引用全局变量是可以的，但是当你要改变它时，需要加上<code>global</code>关键字。）</em></p><p>例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    v = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> v</span><br><span class="line">        t = v + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(t)</span><br><span class="line">        v = t</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">v</span>):           <span class="comment"># 传入的参数 v 同样是 outer 作用域的变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> v      <span class="comment"># 如果你打算改变它，也需要加上 nonlocal 关键字</span></span><br><span class="line">        t = v + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(t)</span><br><span class="line">        v = t</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>如果你熟悉 javascript 或者其他可以使用闭包的语言，会因为 Python 处理作用域的机制遇到麻烦。</p><h3 id="下面是对于几种情况的分析"><a href="#下面是对于几种情况的分析" class="headerlink" title="下面是对于几种情况的分析"></a>下面是对于几种情况的分析</h3><p>先来看第一种情况，内部作用域仅仅使用外部变量而不改变它：</p><p><img src="/2016/11/local-var-in-python-closure/right_closure_1.jpg"></p><p><img src="/2016/11/local-var-in-python-closure/right_closure_2.jpg"></p><p>这种是一种正确的情况。</p><p>从 <code>print</code> 出的<code>v.__str__</code>可以看到 v 的地址是<code>0x5C7D5920</code>；<code>a.__closure__</code>是 a 包含的cell对象的元组，可以看到里面只有一个cell对象，并且持有一个 int 类型的对象，地址同样是<code>0x5C7D5920</code>。</p><p><em>（一个 cell 对象用来保存一个在多个作用域中被引用的变量的值。例如这里的 v 在 outer 中被引用，也在inner中被引用，它就会被保存在一个 cell 对象里。）</em></p><p>后一张图是<code>dis.dis(a)</code>得到的字节码。</p><p><code>LOAD_DEFRED</code>是从cell中得到对象的内容并 push 进栈。也就是说，是从 cell 里得到的 v 值。</p><hr><p>第二种情况，内部作用域改变外部变量：</p><p><img src="/2016/11/local-var-in-python-closure/wrong_closure_1.jpg"></p><p><img src="/2016/11/local-var-in-python-closure/wrong_closure_2.jpg"></p><p>这种情况调用<code>a()</code>时会报错。</p><p><code>a.__closure__</code>没有内容，也就是说，它并不认为 inner 里引用了 outer 作用域的变量，所以并没有创建 cell 来存储任何变量。</p><p>看字节码。第一行就是<code>LOAD_FAST</code>，把变量 v 的值压入栈。而在此之前 v 并没有被定义，于是会在这里报错。</p><hr><p>第三种情况，使用 nonlocal 关键字：</p><p><img src="/2016/11/local-var-in-python-closure/nonlocal_closure_1.jpg"></p><p><img src="/2016/11/local-var-in-python-closure/nonlocal_closure_2.jpg"></p><p><code>a.__closure__</code>有一个 cell 对象，且它持有的一个对象的地址和<code>print</code>看到的 v 的地址相同。</p><p>字节码里的 20 和 23 开头的这两行是<code>v = t</code>的步骤。去掉这个，字节码以及<code>a.__closure__</code>都和第一种情况完全相同。也就是说，内部的 v 是用一个 cell 对象储存起来、和外部 v 同样的对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Python作用域的一些麻烦&quot;&gt;&lt;a href=&quot;#Python作用域的一些麻烦&quot; class=&quot;headerlink&quot; title=&quot;Python作用域的一些麻烦&quot;&gt;&lt;/a&gt;Python作用域的一些麻烦&lt;/h3&gt;&lt;p&gt;Python 的作用域有这样的规则，你在内部</summary>
      
    
    
    
    <category term="编程" scheme="https://jeff.wtf/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>通过弹幕信息得到Bilibili用户的ID</title>
    <link href="https://jeff.wtf/2016/11/get-bilibili-user/"/>
    <id>https://jeff.wtf/2016/11/get-bilibili-user/</id>
    <published>2016-11-19T13:15:10.000Z</published>
    <updated>2022-08-18T17:12:52.558Z</updated>
    
    <content type="html"><![CDATA[<p>当你打开一个视频页面的源代码，可以找到某一行，在播放器的位置，有一个 cid 参数。</p><p><img src="/2016/11/get-bilibili-user/source_code.png"></p><p>B 站发送的请求里也可以看到弹幕请求：</p><p><img src="/2016/11/get-bilibili-user/danmu_list.png"></p><p>请求弹幕的地址是<code>http://comment.bilibili.com/看到的cid.xml</code></p><p>弹幕信息的内容：<br><code>&lt;d p=&quot;时间,模式,字体大小,颜色,时间戳,弹幕池,？？？,弹幕ID&quot;&gt;内容&lt;/d&gt;</code>。</p><p>从这里并不能看到用户的 ID 。上面？？？的部分应该是用户 ID 的某种 hash 。</p><p>测试一下。我的B站空间是 <a href="http://space.bilibili.com/4764287/">http://space.bilibili.com/4764287/</a> ，其中 <code>4764287</code> 是我的 ID 。在弹幕列表找到自己发过的弹幕，？？？部分是 <code>01da63f0</code> 。</p><p>经过一些测试，<strong>最后发现 <code>4764287</code> 经过 CRC32b hash 结果是 <code>f063da01</code> ，而储存在弹幕信息里的值是 <code>01da63f0</code> 。也就是说，弹幕信息？？？部分是用户 ID CRC32b 之后得到的结果按每两位一组倒序排列的结果。</strong></p><p>所以，已知弹幕信息，想逆向找到发弹幕的用户，需要有所有用户 ID 的 CRC32b 彩虹表（现在 B 站用户 ID 为 1 到接近 60, 000, 000）即可。</p><p>而且已经有人做了这件事：<a href="https://danmu.fuckbilibili.com/">https://danmu.fuckbilibili.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当你打开一个视频页面的源代码，可以找到某一行，在播放器的位置，有一个 cid 参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/11/get-bilibili-user/source_code.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;B 站发送的请求里也可以看到弹幕请求：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>和摇滚烤鸡的失之交臂</title>
    <link href="https://jeff.wtf/2015/09/rock-roast-chicken/"/>
    <id>https://jeff.wtf/2015/09/rock-roast-chicken/</id>
    <published>2015-09-16T12:00:00.000Z</published>
    <updated>2022-08-16T14:08:06.508Z</updated>
    
    <content type="html"><![CDATA[<p>接近六点三十分的时候，我和昨天一样在教室巡视了一圈，最后决定回宿舍。</p><p><em>这是我最近的常态，平均每天我会翘掉2节课。</em></p><p>回宿舍的路上突然很想吃华莱士的烤鸡，我翻了一下口袋发现身上只有19块钱。华莱士的烤鸡要26块钱，所以显然19块钱是吃不起烤鸡的。</p><p><em>不过我还是决定去中区食堂感受一下那个窒息的气味。</em></p><p>在中区买一碗麻辣烫吃掉之后手上还剩10块5毛。这家麻辣烫在几个月前还是我最喜欢的一家，今天发现其实他家也没那么好吃，西区好几家都比他强。</p><p>又路过以前常去的奶茶店，我最喜欢喝他家的草莓奶茶。想想觉得粉色的草莓奶茶不太适合，于是点了一杯四块钱的蓝莓奶茶。但是真的拿在手上的时候觉得蓝莓奶茶的紫色也不是特别合适。</p><p><em>出奶茶店的时候，一个忧郁的男孩子看着空的交通银行取款机发呆。</em></p><p>我一边走一边好奇地看着他。</p><p>当我的视线绕开他的时候，我看到被他挡住的一家摊子，里面很多只鸡在旋转，旋转鸡的下面是燃烧的碳。这家路边摊名字叫摇滚烤鸡，名字下面印着烤鸡15元。</p><p><em>胃里还消化着快要让我吃吐出来的麻辣烫，手里拿着我一点都不爱喝的蓝莓奶茶，我就这样和摇滚烤鸡失之交臂。</em></p><p>我后悔得肠子都要悔青了。我一边后悔一边念叨，我想要是从教室出来之后不去校医院旁边捕获那只鸟的坐标就好了，那样我就会先路过摇滚烤鸡，然后买一只，什么事情都不会发生，我还是以为中区的麻辣烫很不错，还是以为蓝莓奶茶和草莓奶茶只是有颜色的区别；我又想，当我想吃烤鸡的时候，就不应该用麻辣烫来代替，我不饿，我只是想吃烤鸡而已，如果我没有买麻辣烫，只是买了四块钱的奶茶，现在还剩15块可以买一只。</p><p><em>我又想，要是我带了30块钱就好了，这样还是可以买一只。</em></p><p>可是仔细想想，好像也不是这样，即使钱带够了，我现在也吃不下去了。</p><p>我以为限制我的只是钱而已，我以为我手上的钱是有限的，选了麻辣烫就不能选择摇滚烤鸡。其实限制我的条件有很多，比如如果我吃完麻辣烫，为了消化它，我又去操场走了一圈，再回去的时候摇滚烧烤已经收摊了；就算像现在这样，运气好，我碰到了摇滚烤鸡，可是我的胃也没有容纳它的位置了。</p><p><em>限制住我的条件那么多那么多。所以，当我以为钱不够吃到烤鸡的时候，我想到了我以为很好的麻辣烫。</em></p><p>这一刻开始，我能得到我渴望的烤鸡的机会就很小了。</p><p>限制住我的东西太多了，有限的东西太多了。最好的解决办法是，当我想吃烤鸡的时候，就不要吃麻辣烫来代替。</p><p>这样，可能我会碰到一家摇滚烤鸡，我心满意足甚至心怀感激地买了烤鸡，什么都不会发生，中区麻辣烫还是我印象中最好的一家。</p><p><em>也可能我碰不到卖烤鸡的路边摊，回宿舍之后随便找了点东西吃掉了。</em></p><p>当然了，这都是在我没吃到摇滚烤鸡情境下的猜测。所以还有一种可能，我如愿以偿地吃到了烤鸡，却又嫌弃烤鸡跟我想象的有差距，对它嗤之以鼻，顺便说一句：“哼，还不如去吃麻辣烫呢。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接近六点三十分的时候，我和昨天一样在教室巡视了一圈，最后决定回宿舍。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是我最近的常态，平均每天我会翘掉2节课。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;回宿舍的路上突然很想吃华莱士的烤鸡，我翻了一下口袋发现身上只有19块钱。华莱士的烤鸡要26块钱，所以显然19块钱是</summary>
      
    
    
    
    <category term="随笔" scheme="https://jeff.wtf/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
